// C++11 <type_traits> -*- C++ -*-

// Copyright (C) 2007-2023 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/type_traits
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_TYPE_TRAITS
#define _GLIBCXX_TYPE_TRAITS 1

#pragma GCC system_header

#if __cplusplus < 201103L
#  include <bits/c++0x_warning.h>
#else

// Predefined symbols and macros -*- C++ -*-

// Copyright (C) 1997-2023 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/c++config.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{version}
 */

#  ifndef _GLIBCXX_CXX_CONFIG_H
#    define _GLIBCXX_CXX_CONFIG_H 1

// The major release number for the GCC release the C++ library belongs to.
#    define _GLIBCXX_RELEASE      13

// The datestamp of the C++ library in compressed ISO date format.
#    define __GLIBCXX__           20240619

// Macros for various attributes.
//   _GLIBCXX_PURE
//   _GLIBCXX_CONST
//   _GLIBCXX_NORETURN
//   _GLIBCXX_NOTHROW
//   _GLIBCXX_VISIBILITY
#    ifndef _GLIBCXX_PURE
#      define _GLIBCXX_PURE __attribute__((__pure__))
#    endif

#    ifndef _GLIBCXX_CONST
#      define _GLIBCXX_CONST __attribute__((__const__))
#    endif

#    ifndef _GLIBCXX_NORETURN
#      define _GLIBCXX_NORETURN __attribute__((__noreturn__))
#    endif

// See below for C++
#    ifndef _GLIBCXX_NOTHROW
#      ifndef __cplusplus
#        define _GLIBCXX_NOTHROW __attribute__((__nothrow__))
#      endif
#    endif

// Macros for visibility attributes.
//   _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY
//   _GLIBCXX_VISIBILITY
#    define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY 1

#    if _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY
#      define _GLIBCXX_VISIBILITY(V) __attribute__((__visibility__(#V)))
#    else
// If this is not supplied by the OS-specific or CPU-specific
// headers included below, it will be defined to an empty default.
#      define _GLIBCXX_VISIBILITY(V) _GLIBCXX_PSEUDO_VISIBILITY(V)
#    endif

// Macros for deprecated attributes.
//   _GLIBCXX_USE_DEPRECATED
//   _GLIBCXX_DEPRECATED
//   _GLIBCXX_DEPRECATED_SUGGEST( string-literal )
//   _GLIBCXX11_DEPRECATED
//   _GLIBCXX11_DEPRECATED_SUGGEST( string-literal )
//   _GLIBCXX14_DEPRECATED
//   _GLIBCXX14_DEPRECATED_SUGGEST( string-literal )
//   _GLIBCXX17_DEPRECATED
//   _GLIBCXX17_DEPRECATED_SUGGEST( string-literal )
//   _GLIBCXX20_DEPRECATED
//   _GLIBCXX20_DEPRECATED_SUGGEST( string-literal )
//   _GLIBCXX23_DEPRECATED
//   _GLIBCXX23_DEPRECATED_SUGGEST( string-literal )
#    ifndef _GLIBCXX_USE_DEPRECATED
#      define _GLIBCXX_USE_DEPRECATED 1
#    endif

#    if defined(__DEPRECATED)
#      define _GLIBCXX_DEPRECATED __attribute__((__deprecated__))
#      define _GLIBCXX_DEPRECATED_SUGGEST(ALT)                                                     \
        __attribute__((__deprecated__("use '" ALT "' instead")))
#    else
#      define _GLIBCXX_DEPRECATED
#      define _GLIBCXX_DEPRECATED_SUGGEST(ALT)
#    endif

#    if defined(__DEPRECATED) && (__cplusplus >= 201103L)
#      define _GLIBCXX11_DEPRECATED              _GLIBCXX_DEPRECATED
#      define _GLIBCXX11_DEPRECATED_SUGGEST(ALT) _GLIBCXX_DEPRECATED_SUGGEST(ALT)
#    else
#      define _GLIBCXX11_DEPRECATED
#      define _GLIBCXX11_DEPRECATED_SUGGEST(ALT)
#    endif

#    if defined(__DEPRECATED) && (__cplusplus >= 201402L)
#      define _GLIBCXX14_DEPRECATED              _GLIBCXX_DEPRECATED
#      define _GLIBCXX14_DEPRECATED_SUGGEST(ALT) _GLIBCXX_DEPRECATED_SUGGEST(ALT)
#    else
#      define _GLIBCXX14_DEPRECATED
#      define _GLIBCXX14_DEPRECATED_SUGGEST(ALT)
#    endif

#    if defined(__DEPRECATED) && (__cplusplus >= 201703L)
#      define _GLIBCXX17_DEPRECATED              [[__deprecated__]]
#      define _GLIBCXX17_DEPRECATED_SUGGEST(ALT) _GLIBCXX_DEPRECATED_SUGGEST(ALT)
#    else
#      define _GLIBCXX17_DEPRECATED
#      define _GLIBCXX17_DEPRECATED_SUGGEST(ALT)
#    endif

#    if defined(__DEPRECATED) && (__cplusplus >= 202002L)
#      define _GLIBCXX20_DEPRECATED              [[__deprecated__]]
#      define _GLIBCXX20_DEPRECATED_SUGGEST(ALT) _GLIBCXX_DEPRECATED_SUGGEST(ALT)
#    else
#      define _GLIBCXX20_DEPRECATED
#      define _GLIBCXX20_DEPRECATED_SUGGEST(ALT)
#    endif

#    if defined(__DEPRECATED) && (__cplusplus >= 202100L)
#      define _GLIBCXX23_DEPRECATED              [[__deprecated__]]
#      define _GLIBCXX23_DEPRECATED_SUGGEST(ALT) _GLIBCXX_DEPRECATED_SUGGEST(ALT)
#    else
#      define _GLIBCXX23_DEPRECATED
#      define _GLIBCXX23_DEPRECATED_SUGGEST(ALT)
#    endif

// Macros for ABI tag attributes.
#    ifndef _GLIBCXX_ABI_TAG_CXX11
#      define _GLIBCXX_ABI_TAG_CXX11 __attribute((__abi_tag__("cxx11")))
#    endif

// Macro to warn about unused results.
#    if __cplusplus >= 201703L
#      define _GLIBCXX_NODISCARD [[__nodiscard__]]
#    else
#      define _GLIBCXX_NODISCARD
#    endif

#    if __cplusplus

// Macro for constexpr, to support in mixed 03/0x mode.
#      ifndef _GLIBCXX_CONSTEXPR
#        if __cplusplus >= 201103L
#          define _GLIBCXX_CONSTEXPR     constexpr
#          define _GLIBCXX_USE_CONSTEXPR constexpr
#        else
#          define _GLIBCXX_CONSTEXPR
#          define _GLIBCXX_USE_CONSTEXPR const
#        endif
#      endif

#      ifndef _GLIBCXX14_CONSTEXPR
#        if __cplusplus >= 201402L
#          define _GLIBCXX14_CONSTEXPR constexpr
#        else
#          define _GLIBCXX14_CONSTEXPR
#        endif
#      endif

#      ifndef _GLIBCXX17_CONSTEXPR
#        if __cplusplus >= 201703L
#          define _GLIBCXX17_CONSTEXPR constexpr
#        else
#          define _GLIBCXX17_CONSTEXPR
#        endif
#      endif

#      ifndef _GLIBCXX20_CONSTEXPR
#        if __cplusplus >= 202002L
#          define _GLIBCXX20_CONSTEXPR constexpr
#        else
#          define _GLIBCXX20_CONSTEXPR
#        endif
#      endif

#      ifndef _GLIBCXX23_CONSTEXPR
#        if __cplusplus >= 202100L
#          define _GLIBCXX23_CONSTEXPR constexpr
#        else
#          define _GLIBCXX23_CONSTEXPR
#        endif
#      endif

#      ifndef _GLIBCXX17_INLINE
#        if __cplusplus >= 201703L
#          define _GLIBCXX17_INLINE inline
#        else
#          define _GLIBCXX17_INLINE
#        endif
#      endif

// Macro for noexcept, to support in mixed 03/0x mode.
#      ifndef _GLIBCXX_NOEXCEPT
#        if __cplusplus >= 201103L
#          define _GLIBCXX_NOEXCEPT         noexcept
#          define _GLIBCXX_NOEXCEPT_IF(...) noexcept(__VA_ARGS__)
#          define _GLIBCXX_USE_NOEXCEPT     noexcept
#          define _GLIBCXX_THROW(_EXC)
#        else
#          define _GLIBCXX_NOEXCEPT
#          define _GLIBCXX_NOEXCEPT_IF(...)
#          define _GLIBCXX_USE_NOEXCEPT throw()
#          define _GLIBCXX_THROW(_EXC)  throw(_EXC)
#        endif
#      endif

#      ifndef _GLIBCXX_NOTHROW
#        define _GLIBCXX_NOTHROW _GLIBCXX_USE_NOEXCEPT
#      endif

#      ifndef _GLIBCXX_THROW_OR_ABORT
#        if __cpp_exceptions
#          define _GLIBCXX_THROW_OR_ABORT(_EXC) (throw(_EXC))
#        else
#          define _GLIBCXX_THROW_OR_ABORT(_EXC) (__builtin_abort())
#        endif
#      endif

#      if __cpp_noexcept_function_type
#        define _GLIBCXX_NOEXCEPT_PARM , bool _NE
#        define _GLIBCXX_NOEXCEPT_QUAL noexcept(_NE)
#      else
#        define _GLIBCXX_NOEXCEPT_PARM
#        define _GLIBCXX_NOEXCEPT_QUAL
#      endif

// Macro for extern template, ie controlling template linkage via use
// of extern keyword on template declaration. As documented in the g++
// manual, it inhibits all implicit instantiations and is used
// throughout the library to avoid multiple weak definitions for
// required types that are already explicitly instantiated in the
// library binary. This substantially reduces the binary size of
// resulting executables.
// Special case: _GLIBCXX_EXTERN_TEMPLATE == -1 disallows extern
// templates only in basic_string, thus activating its debug-mode
// checks even at -O0.
#      define _GLIBCXX_EXTERN_TEMPLATE 1

/*
  Outline of libstdc++ namespaces.

  namespace std
  {
    namespace __debug { }
    namespace __parallel { }
    namespace __cxx1998 { }

    namespace __detail {
      namespace __variant { }				// C++17
    }

    namespace rel_ops { }

    namespace tr1
    {
      namespace placeholders { }
      namespace regex_constants { }
      namespace __detail { }
    }

    namespace tr2 { }
    
    namespace decimal { }

    namespace chrono { }				// C++11
    namespace placeholders { }				// C++11
    namespace regex_constants { }			// C++11
    namespace this_thread { }				// C++11
    inline namespace literals {				// C++14
      inline namespace chrono_literals { }		// C++14
      inline namespace complex_literals { }		// C++14
      inline namespace string_literals { }		// C++14
      inline namespace string_view_literals { }		// C++17
    }
  }

  namespace abi { }

  namespace __gnu_cxx
  {
    namespace __detail { }
  }

  For full details see:
  http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespaces.html
*/
namespace std {
typedef __SIZE_TYPE__     size_t;
typedef __PTRDIFF_TYPE__  ptrdiff_t;

#      if __cplusplus >= 201103L
typedef decltype(nullptr) nullptr_t;
#      endif

#      pragma GCC visibility push(default)
// This allows the library to terminate without including all of <exception>
// and without making the declaration of std::terminate visible to users.
extern "C++" __attribute__((__noreturn__, __always_inline__)) inline void
__terminate() _GLIBCXX_USE_NOEXCEPT {
  void terminate() _GLIBCXX_USE_NOEXCEPT __attribute__((__noreturn__));
  terminate();
}
#      pragma GCC visibility pop
} // namespace std

#      define _GLIBCXX_USE_DUAL_ABI 1

#      if !_GLIBCXX_USE_DUAL_ABI
// Ignore any pre-defined value of _GLIBCXX_USE_CXX11_ABI
#        undef _GLIBCXX_USE_CXX11_ABI
#      endif

#      ifndef _GLIBCXX_USE_CXX11_ABI
#        define _GLIBCXX_USE_CXX11_ABI 1
#      endif

#      if _GLIBCXX_USE_CXX11_ABI
namespace std {
inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {}
} // namespace std
namespace __gnu_cxx {
inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {}
} // namespace __gnu_cxx
#        define _GLIBCXX_NAMESPACE_CXX11       __cxx11::
#        define _GLIBCXX_BEGIN_NAMESPACE_CXX11 namespace __cxx11 {
#        define _GLIBCXX_END_NAMESPACE_CXX11   }
#        define _GLIBCXX_DEFAULT_ABI_TAG       _GLIBCXX_ABI_TAG_CXX11
#      else
#        define _GLIBCXX_NAMESPACE_CXX11
#        define _GLIBCXX_BEGIN_NAMESPACE_CXX11
#        define _GLIBCXX_END_NAMESPACE_CXX11
#        define _GLIBCXX_DEFAULT_ABI_TAG
#      endif

// Non-zero if inline namespaces are used for versioning the entire library.
#      define _GLIBCXX_INLINE_VERSION 0

#      if _GLIBCXX_INLINE_VERSION
// Inline namespace for symbol versioning of (nearly) everything in std.
#        define _GLIBCXX_BEGIN_NAMESPACE_VERSION namespace __8 {
#        define _GLIBCXX_END_NAMESPACE_VERSION   }
// Unused when everything in std is versioned anyway.
#        define _GLIBCXX_BEGIN_INLINE_ABI_NAMESPACE(X)
#        define _GLIBCXX_END_INLINE_ABI_NAMESPACE(X)

namespace std {
inline _GLIBCXX_BEGIN_NAMESPACE_VERSION
#        if __cplusplus >= 201402L
    inline namespace literals {
  inline namespace chrono_literals {}
  inline namespace complex_literals {}
  inline namespace string_literals {}
#          if __cplusplus > 201402L
  inline namespace string_view_literals {}
#          endif // C++17
}
#        endif   // C++14
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

namespace __gnu_cxx {
inline _GLIBCXX_BEGIN_NAMESPACE_VERSION _GLIBCXX_END_NAMESPACE_VERSION
}

#      else
// Unused.
#        define _GLIBCXX_BEGIN_NAMESPACE_VERSION
#        define _GLIBCXX_END_NAMESPACE_VERSION
// Used to version individual components, e.g. std::_V2::error_category.
#        define _GLIBCXX_BEGIN_INLINE_ABI_NAMESPACE(X) inline namespace X {
#        define _GLIBCXX_END_INLINE_ABI_NAMESPACE(X)   } // inline namespace X
#      endif

// In the case that we don't have a hosted environment, we can't provide the
// debugging mode.  Instead, we do our best and downgrade to assertions.
#      if defined(_GLIBCXX_DEBUG) && !__STDC_HOSTED__
#        undef _GLIBCXX_DEBUG
#        define _GLIBCXX_ASSERTIONS 1
#      endif

// Inline namespaces for special modes: debug, parallel.
#      if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL)
namespace std {
_GLIBCXX_BEGIN_NAMESPACE_VERSION

// Non-inline namespace for components replaced by alternates in active mode.
namespace __cxx1998 {
#        if _GLIBCXX_USE_CXX11_ABI
inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {}
#        endif
} // namespace __cxx1998

_GLIBCXX_END_NAMESPACE_VERSION

// Inline namespace for debug mode.
#        ifdef _GLIBCXX_DEBUG
inline namespace __debug {}
#        endif

// Inline namespaces for parallel mode.
#        ifdef _GLIBCXX_PARALLEL
inline namespace __parallel {}
#        endif
} // namespace std

// Check for invalid usage and unsupported mixed-mode use.
#        if defined(_GLIBCXX_DEBUG) && defined(_GLIBCXX_PARALLEL)
#          error illegal use of multiple inlined namespaces
#        endif

// Check for invalid use due to lack for weak symbols.
#        if __NO_INLINE__ && !__GXX_WEAK__
#          warning currently using inlined namespace mode which may fail \
   without inlining due to lack of weak symbols
#        endif
#      endif

// Macros for namespace scope. Either namespace std:: or the name
// of some nested namespace within it corresponding to the active mode.
// _GLIBCXX_STD_A
// _GLIBCXX_STD_C
//
// Macros for opening/closing conditional namespaces.
// _GLIBCXX_BEGIN_NAMESPACE_ALGO
// _GLIBCXX_END_NAMESPACE_ALGO
// _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
// _GLIBCXX_END_NAMESPACE_CONTAINER
#      if defined(_GLIBCXX_DEBUG)
#        define _GLIBCXX_STD_C                     __cxx1998
#        define _GLIBCXX_BEGIN_NAMESPACE_CONTAINER namespace _GLIBCXX_STD_C {
#        define _GLIBCXX_END_NAMESPACE_CONTAINER   }
#      else
#        define _GLIBCXX_STD_C std
#        define _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
#        define _GLIBCXX_END_NAMESPACE_CONTAINER
#      endif

#      ifdef _GLIBCXX_PARALLEL
#        define _GLIBCXX_STD_A                __cxx1998
#        define _GLIBCXX_BEGIN_NAMESPACE_ALGO namespace _GLIBCXX_STD_A {
#        define _GLIBCXX_END_NAMESPACE_ALGO   }
#      else
#        define _GLIBCXX_STD_A std
#        define _GLIBCXX_BEGIN_NAMESPACE_ALGO
#        define _GLIBCXX_END_NAMESPACE_ALGO
#      endif

// GLIBCXX_ABI Deprecated
// Define if compatibility should be provided for -mlong-double-64.
#      undef _GLIBCXX_LONG_DOUBLE_COMPAT

// Define if compatibility should be provided for alternative 128-bit long
// double formats. Not possible for Clang until __ibm128 is supported.
#      ifndef __clang__
#        undef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT
#      endif

// Inline namespaces for long double 128 modes.
#      if defined _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT && defined __LONG_DOUBLE_IEEE128__
namespace std {
// Namespaces for 128-bit IEEE long double format on 64-bit POWER LE.
inline namespace __gnu_cxx_ieee128 {}
inline namespace __gnu_cxx11_ieee128 {}
} // namespace std
#        define _GLIBCXX_NAMESPACE_LDBL                __gnu_cxx_ieee128::
#        define _GLIBCXX_BEGIN_NAMESPACE_LDBL          namespace __gnu_cxx_ieee128 {
#        define _GLIBCXX_END_NAMESPACE_LDBL            }
#        define _GLIBCXX_NAMESPACE_LDBL_OR_CXX11       __gnu_cxx11_ieee128::
#        define _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 namespace __gnu_cxx11_ieee128 {
#        define _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11   }

#      else // _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT && IEEE128

#        if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
namespace std {
inline namespace __gnu_cxx_ldbl128 {}
} // namespace std
#          define _GLIBCXX_NAMESPACE_LDBL       __gnu_cxx_ldbl128::
#          define _GLIBCXX_BEGIN_NAMESPACE_LDBL namespace __gnu_cxx_ldbl128 {
#          define _GLIBCXX_END_NAMESPACE_LDBL   }
#        else
#          define _GLIBCXX_NAMESPACE_LDBL
#          define _GLIBCXX_BEGIN_NAMESPACE_LDBL
#          define _GLIBCXX_END_NAMESPACE_LDBL
#        endif

#        if _GLIBCXX_USE_CXX11_ABI
#          define _GLIBCXX_NAMESPACE_LDBL_OR_CXX11       _GLIBCXX_NAMESPACE_CXX11
#          define _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_BEGIN_NAMESPACE_CXX11
#          define _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11   _GLIBCXX_END_NAMESPACE_CXX11
#        else
#          define _GLIBCXX_NAMESPACE_LDBL_OR_CXX11       _GLIBCXX_NAMESPACE_LDBL
#          define _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_BEGIN_NAMESPACE_LDBL
#          define _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11   _GLIBCXX_END_NAMESPACE_LDBL
#        endif

#      endif // _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT && IEEE128

namespace std {
#      pragma GCC visibility push(default)
// Internal version of std::is_constant_evaluated().
// This can be used without checking if the compiler supports the feature.
// The macro _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED can be used to check if
// the compiler support is present to make this function work as expected.
_GLIBCXX_CONSTEXPR inline bool __is_constant_evaluated() _GLIBCXX_NOEXCEPT {
#      if __cpp_if_consteval >= 202106L
#        define _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED 1
  if consteval {
    return true;
  } else {
    return false;
  }
#      elif __cplusplus >= 201103L && __has_builtin(__builtin_is_constant_evaluated)
#        define _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED 1
  return __builtin_is_constant_evaluated();
#      else
  return false;
#      endif
}
#      pragma GCC visibility pop
} // namespace std

// Debug Mode implies checking assertions.
#      if defined(_GLIBCXX_DEBUG) && !defined(_GLIBCXX_ASSERTIONS)
#        define _GLIBCXX_ASSERTIONS 1
#      endif

// Disable std::string explicit instantiation declarations in order to assert.
#      ifdef _GLIBCXX_ASSERTIONS
#        undef _GLIBCXX_EXTERN_TEMPLATE
#        define _GLIBCXX_EXTERN_TEMPLATE -1
#      endif

#      if _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED
#        define __glibcxx_constexpr_assert(cond)                                                   \
          if (std::__is_constant_evaluated() && !bool(cond))                                       \
          __builtin_unreachable() /* precondition violation detected! */
#      else
#        define __glibcxx_constexpr_assert(unevaluated)
#      endif

#      define _GLIBCXX_VERBOSE_ASSERT 1

// Assert.
#      if defined(_GLIBCXX_ASSERTIONS) || defined(_GLIBCXX_PARALLEL) ||                            \
          defined(_GLIBCXX_PARALLEL_ASSERTIONS)
#        ifdef _GLIBCXX_VERBOSE_ASSERT
namespace std {
#          pragma GCC visibility push(default)
// Avoid the use of assert, because we're trying to keep the <cassert>
// include out of the mix.
extern "C++" _GLIBCXX_NORETURN void
__glibcxx_assert_fail(const char *__file, int __line, const char *__function,
                      const char *__condition) _GLIBCXX_NOEXCEPT;
#          pragma GCC visibility pop
} // namespace std
#          define __glibcxx_assert_impl(_Condition)                                                \
            if (__builtin_expect(!bool(_Condition), false)) {                                      \
              __glibcxx_constexpr_assert(false);                                                   \
              std::__glibcxx_assert_fail(__FILE__, __LINE__, __PRETTY_FUNCTION__, #_Condition);    \
            }
#        else // ! VERBOSE_ASSERT
#          define __glibcxx_assert_impl(_Condition)                                                \
            if (__builtin_expect(!bool(_Condition), false)) {                                      \
              __glibcxx_constexpr_assert(false);                                                   \
              __builtin_abort();                                                                   \
            }
#        endif
#      endif

#      if defined(_GLIBCXX_ASSERTIONS)
#        define __glibcxx_assert(cond)                                                             \
          do {                                                                                     \
            __glibcxx_assert_impl(cond);                                                           \
          } while (false)
#      else
#        define __glibcxx_assert(cond)                                                             \
          do {                                                                                     \
            __glibcxx_constexpr_assert(cond);                                                      \
          } while (false)
#      endif

// Macro indicating that TSAN is in use.
#      if __SANITIZE_THREAD__
#        define _GLIBCXX_TSAN 1
#      elif defined __has_feature
#        if __has_feature(thread_sanitizer)
#          define _GLIBCXX_TSAN 1
#        endif
#      endif

// Macros for race detectors.
// _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) and
// _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) should be used to explain
// atomic (lock-free) synchronization to race detectors:
// the race detector will infer a happens-before arc from the former to the
// latter when they share the same argument pointer.
//
// The most frequent use case for these macros (and the only case in the
// current implementation of the library) is atomic reference counting:
//   void _M_remove_reference()
//   {
//     _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
//     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) <= 0)
//       {
//         _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
//         _M_destroy(__a);
//       }
//   }
// The annotations in this example tell the race detector that all memory
// accesses occurred when the refcount was positive do not race with
// memory accesses which occurred after the refcount became zero.
#      ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE
#        define _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A)
#      endif
#      ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER
#        define _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A)
#      endif

// Macros for C linkage: define extern "C" linkage only when using C++.
#      define _GLIBCXX_BEGIN_EXTERN_C extern "C" {
#      define _GLIBCXX_END_EXTERN_C   }

#      define _GLIBCXX_USE_ALLOCATOR_NEW 1

#      ifdef __SIZEOF_INT128__
#        if !defined __GLIBCXX_TYPE_INT_N_0 && !defined __STRICT_ANSI__
// If __int128 is supported, we expect __GLIBCXX_TYPE_INT_N_0 to be defined
// unless the compiler is in strict mode. If it's not defined and the strict
// macro is not defined, something is wrong.
#          warning "__STRICT_ANSI__ seems to have been undefined; this is not supported"
#        endif
#      endif

#    else // !__cplusplus
#      define _GLIBCXX_BEGIN_EXTERN_C
#      define _GLIBCXX_END_EXTERN_C
#    endif

// First includes.

// Pick up any OS-specific definitions.
// Specific definitions for GNU/Linux  -*- C++ -*-

// Copyright (C) 2000-2023 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/os_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */

#    ifndef _GLIBCXX_OS_DEFINES
#      define _GLIBCXX_OS_DEFINES 1

// System-specific #define, typedefs, corrections, etc, go here.  This
// file will come before all others.

// This keeps isalnum, et al from being propagated as macros.
#      define __NO_CTYPE          1

/* Copyright (C) 1991-2023 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

#      ifndef _FEATURES_H
#        define _FEATURES_H 1

/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
   _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
   __STDC_WANT_LIB_EXT2__
			Extensions to ISO C99 from TR 27431-2:2010.
   __STDC_WANT_IEC_60559_BFP_EXT__
			Extensions to ISO C11 from TS 18661-1:2014.
   __STDC_WANT_IEC_60559_FUNCS_EXT__
			Extensions to ISO C11 from TS 18661-4:2015.
   __STDC_WANT_IEC_60559_TYPES_EXT__
			Extensions to ISO C11 from TS 18661-3:2015.
   __STDC_WANT_IEC_60559_EXT__
			ISO C2X interfaces defined only in Annex F.

   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _ATFILE_SOURCE	Additional *at interfaces.
   _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _DEFAULT_SOURCE	The default set of features (taking precedence over
			__STRICT_ANSI__).

   _FORTIFY_SOURCE	Add security hardening to many library functions.
			Set to 1, 2 or 3; 3 performs stricter checks than 2, which
			performs stricter checks than 1.

   _REENTRANT, _THREAD_SAFE
			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.

   The `-ansi' switch to the GNU C compiler, and standards conformance
   options such as `-std=c99', define __STRICT_ANSI__.  If none of
   these are defined, or if _DEFAULT_SOURCE is defined, the default is
   to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200809L, as well as enabling miscellaneous functions from BSD and
   SVID.  If more than one of these are defined, they accumulate.  For
   example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
   give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __GLIBC_USE (F)	Define things from feature set F.  This is defined
			to 1 or 0; the subsequent macros are either defined
			or undefined, and those tests should be moved to
			__GLIBC_USE.
   __USE_ISOC11		Define ISO C11 things.
   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_ISOCXX11	Define ISO C++11 things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_MISC		Define things from 4.3BSD or System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
   __USE_GNU		Define GNU extensions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.

   ISO C feature test macros depend on the definition of the macro
   when an affected header is included, not when the first system
   header is included, and so they are handled in
   <bits/libc-header-start.h>, which does not have a multiple include
   guard.  Feature test macros that can be handled from the first
   system header included are handled here.  */

/* Undefine everything, so we get a clean slate.  */
#        undef __USE_ISOC11
#        undef __USE_ISOC99
#        undef __USE_ISOC95
#        undef __USE_ISOCXX11
#        undef __USE_POSIX
#        undef __USE_POSIX2
#        undef __USE_POSIX199309
#        undef __USE_POSIX199506
#        undef __USE_XOPEN
#        undef __USE_XOPEN_EXTENDED
#        undef __USE_UNIX98
#        undef __USE_XOPEN2K
#        undef __USE_XOPEN2KXSI
#        undef __USE_XOPEN2K8
#        undef __USE_XOPEN2K8XSI
#        undef __USE_LARGEFILE
#        undef __USE_LARGEFILE64
#        undef __USE_FILE_OFFSET64
#        undef __USE_MISC
#        undef __USE_ATFILE
#        undef __USE_DYNAMIC_STACK_SIZE
#        undef __USE_GNU
#        undef __USE_FORTIFY_LEVEL
#        undef __KERNEL_STRICT_NAMES
#        undef __GLIBC_USE_ISOC2X
#        undef __GLIBC_USE_DEPRECATED_GETS
#        undef __GLIBC_USE_DEPRECATED_SCANF
#        undef __GLIBC_USE_C2X_STRTOL

/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */
#        ifndef _LOOSE_KERNEL_NAMES
#          define __KERNEL_STRICT_NAMES
#        endif

/* Convenience macro to test the version of gcc.
   Use like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
   added in 2.0.  */
#        if defined __GNUC__ && defined __GNUC_MINOR__
#          define __GNUC_PREREQ(maj, min)                                                          \
            ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
#        else
#          define __GNUC_PREREQ(maj, min) 0
#        endif

/* Similarly for clang.  Features added to GCC after version 4.2 may
   or may not also be available in clang, and clang's definitions of
   __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
   features can be queried via __has_extension/__has_feature.  */
#        if defined __clang_major__ && defined __clang_minor__
#          define __glibc_clang_prereq(maj, min)                                                   \
            ((__clang_major__ << 16) + __clang_minor__ >= ((maj) << 16) + (min))
#        else
#          define __glibc_clang_prereq(maj, min) 0
#        endif

/* Whether to use feature set F.  */
#        define __GLIBC_USE(F) __GLIBC_USE_##F

/* _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
   _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
   issue a warning; the expectation is that the source is being
   transitioned to use the new macro.  */
#        if (defined _BSD_SOURCE || defined _SVID_SOURCE) && !defined _DEFAULT_SOURCE
#          warning "_BSD_SOURCE and _SVID_SOURCE are deprecated, use _DEFAULT_SOURCE"
#          undef _DEFAULT_SOURCE
#          define _DEFAULT_SOURCE 1
#        endif

/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
#        ifdef _GNU_SOURCE
#          undef _ISOC95_SOURCE
#          define _ISOC95_SOURCE 1
#          undef _ISOC99_SOURCE
#          define _ISOC99_SOURCE 1
#          undef _ISOC11_SOURCE
#          define _ISOC11_SOURCE 1
#          undef _ISOC2X_SOURCE
#          define _ISOC2X_SOURCE 1
#          undef _POSIX_SOURCE
#          define _POSIX_SOURCE 1
#          undef _POSIX_C_SOURCE
#          define _POSIX_C_SOURCE 200809L
#          undef _XOPEN_SOURCE
#          define _XOPEN_SOURCE 700
#          undef _XOPEN_SOURCE_EXTENDED
#          define _XOPEN_SOURCE_EXTENDED 1
#          undef _LARGEFILE64_SOURCE
#          define _LARGEFILE64_SOURCE 1
#          undef _DEFAULT_SOURCE
#          define _DEFAULT_SOURCE 1
#          undef _ATFILE_SOURCE
#          define _ATFILE_SOURCE 1
#          undef _DYNAMIC_STACK_SIZE_SOURCE
#          define _DYNAMIC_STACK_SIZE_SOURCE 1
#        endif

/* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
   define _DEFAULT_SOURCE.  */
#        if (defined _DEFAULT_SOURCE ||                                                            \
             (!defined __STRICT_ANSI__ && !defined _ISOC99_SOURCE && !defined _ISOC11_SOURCE &&    \
              !defined _ISOC2X_SOURCE && !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE &&     \
              !defined                                                      _XOPEN_SOURCE))
#          undef _DEFAULT_SOURCE
#          define _DEFAULT_SOURCE 1
#        endif

/* This is to enable the ISO C2X extension.  */
#        if (defined _ISOC2X_SOURCE || (defined __STDC_VERSION__ && __STDC_VERSION__ > 201710L))
#          define __GLIBC_USE_ISOC2X 1
#        else
#          define __GLIBC_USE_ISOC2X 0
#        endif

/* This is to enable the ISO C11 extension.  */
#        if (defined _ISOC11_SOURCE || defined _ISOC2X_SOURCE ||                                   \
             (defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L))
#          define __USE_ISOC11 1
#        endif

/* This is to enable the ISO C99 extension.  */
#        if (defined _ISOC99_SOURCE || defined _ISOC11_SOURCE || defined _ISOC2X_SOURCE ||         \
             (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))
#          define __USE_ISOC99 1
#        endif

/* This is to enable the ISO C90 Amendment 1:1995 extension.  */
#        if (defined _ISOC99_SOURCE || defined _ISOC11_SOURCE || defined _ISOC2X_SOURCE ||         \
             (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199409L))
#          define __USE_ISOC95 1
#        endif

#        ifdef __cplusplus
/* This is to enable compatibility for ISO C++17.  */
#          if __cplusplus >= 201703L
#            define __USE_ISOC11 1
#          endif
/* This is to enable compatibility for ISO C++11.
   Check the temporary macro for now, too.  */
#          if __cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__
#            define __USE_ISOCXX11 1
#            define __USE_ISOC99   1
#          endif
#        endif

/* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
   is defined, use POSIX.1-2008 (or another version depending on
   _XOPEN_SOURCE).  */
#        ifdef _DEFAULT_SOURCE
#          if !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE
#            define __USE_POSIX_IMPLICITLY 1
#          endif
#          undef _POSIX_SOURCE
#          define _POSIX_SOURCE 1
#          undef _POSIX_C_SOURCE
#          define _POSIX_C_SOURCE 200809L
#        endif

#        if ((!defined __STRICT_ANSI__ ||                                                          \
              (defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) >= 500)) &&                            \
             !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE)
#          define _POSIX_SOURCE 1
#          if defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500
#            define _POSIX_C_SOURCE 2
#          elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600
#            define _POSIX_C_SOURCE 199506L
#          elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 700
#            define _POSIX_C_SOURCE 200112L
#          else
#            define _POSIX_C_SOURCE 200809L
#          endif
#          define __USE_POSIX_IMPLICITLY 1
#        endif

/* Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
   defined in all multithreaded code.  GNU libc has not required this
   for many years.  We now treat them as compatibility synonyms for
   _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
   comprehensive support for multithreaded code.  Using them never
   lowers the selected level of POSIX conformance, only raises it.  */
#        if ((!defined _POSIX_C_SOURCE || (_POSIX_C_SOURCE - 0) < 199506L) &&                      \
             (defined _REENTRANT || defined _THREAD_SAFE))
#          define _POSIX_SOURCE 1
#          undef _POSIX_C_SOURCE
#          define _POSIX_C_SOURCE 199506L
#        endif

#        if (defined _POSIX_SOURCE || (defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 1) ||         \
             defined _XOPEN_SOURCE)
#          define __USE_POSIX 1
#        endif

#        if defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCE
#          define __USE_POSIX2 1
#        endif

#        if defined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199309L
#          define __USE_POSIX199309 1
#        endif

#        if defined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199506L
#          define __USE_POSIX199506 1
#        endif

#        if defined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200112L
#          define __USE_XOPEN2K 1
#          undef __USE_ISOC95
#          define __USE_ISOC95 1
#          undef __USE_ISOC99
#          define __USE_ISOC99 1
#        endif

#        if defined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200809L
#          define __USE_XOPEN2K8 1
#          undef _ATFILE_SOURCE
#          define _ATFILE_SOURCE 1
#        endif

#        ifdef _XOPEN_SOURCE
#          define __USE_XOPEN 1
#          if (_XOPEN_SOURCE - 0) >= 500
#            define __USE_XOPEN_EXTENDED 1
#            define __USE_UNIX98         1
#            undef _LARGEFILE_SOURCE
#            define _LARGEFILE_SOURCE 1
#            if (_XOPEN_SOURCE - 0) >= 600
#              if (_XOPEN_SOURCE - 0) >= 700
#                define __USE_XOPEN2K8    1
#                define __USE_XOPEN2K8XSI 1
#              endif
#              define __USE_XOPEN2K    1
#              define __USE_XOPEN2KXSI 1
#              undef __USE_ISOC95
#              define __USE_ISOC95 1
#              undef __USE_ISOC99
#              define __USE_ISOC99 1
#            endif
#          else
#            ifdef _XOPEN_SOURCE_EXTENDED
#              define __USE_XOPEN_EXTENDED 1
#            endif
#          endif
#        endif

#        ifdef _LARGEFILE_SOURCE
#          define __USE_LARGEFILE 1
#        endif

#        ifdef _LARGEFILE64_SOURCE
#          define __USE_LARGEFILE64 1
#        endif

#        if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
#          define __USE_FILE_OFFSET64 1
#        endif

// #        include <features-time64.h>

#        if defined _DEFAULT_SOURCE
#          define __USE_MISC 1
#        endif

#        ifdef _ATFILE_SOURCE
#          define __USE_ATFILE 1
#        endif

#        ifdef _DYNAMIC_STACK_SIZE_SOURCE
#          define __USE_DYNAMIC_STACK_SIZE 1
#        endif

#        ifdef _GNU_SOURCE
#          define __USE_GNU 1
#        endif

#        if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0 && defined __OPTIMIZE__ &&              \
            __OPTIMIZE__ > 0
#          if !__GNUC_PREREQ(4, 1)
#            warning _FORTIFY_SOURCE requires GCC 4.1 or later
#          elif _FORTIFY_SOURCE > 2 && (__glibc_clang_prereq(9, 0) || __GNUC_PREREQ(12, 0))

#            if _FORTIFY_SOURCE > 3
#              warning _FORTIFY_SOURCE > 3 is treated like 3 on this platform
#            endif
#            define __USE_FORTIFY_LEVEL 3
#          elif _FORTIFY_SOURCE > 1
#            if _FORTIFY_SOURCE > 2
#              warning _FORTIFY_SOURCE > 2 is treated like 2 on this platform
#            endif
#            define __USE_FORTIFY_LEVEL 2
#          else
#            define __USE_FORTIFY_LEVEL 1
#          endif
#        endif
#        ifndef __USE_FORTIFY_LEVEL
#          define __USE_FORTIFY_LEVEL 0
#        endif

/* The function 'gets' existed in C89, but is impossible to use
   safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
   compatibility with various implementations of <cstdio>, this test
   must consider only the value of __cplusplus when compiling C++.  */
#        if defined __cplusplus ? __cplusplus >= 201402L : defined __USE_ISOC11
#          define __GLIBC_USE_DEPRECATED_GETS 0
#        else
#          define __GLIBC_USE_DEPRECATED_GETS 1
#        endif

/* GNU formerly extended the scanf functions with modified format
   specifiers %as, %aS, and %a[...] that allocate a buffer for the
   input using malloc.  This extension conflicts with ISO C99, which
   defines %a as a standalone format specifier that reads a floating-
   point number; moreover, POSIX.1-2008 provides the same feature
   using the modifier letter 'm' instead (%ms, %mS, %m[...]).

   We now follow C99 unless GNU extensions are active and the compiler
   is specifically in C89 or C++98 mode (strict or not).  For
   instance, with GCC, -std=gnu11 will have C99-compliant scanf with
   or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
   old extension.  */
#        if (defined __USE_GNU &&                                                                  \
             (defined __cplusplus ? (__cplusplus < 201103L && !defined __GXX_EXPERIMENTAL_CXX0X__) \
                                  : (!defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L)))
#          define __GLIBC_USE_DEPRECATED_SCANF 1
#        else
#          define __GLIBC_USE_DEPRECATED_SCANF 0
#        endif

/* ISO C2X added support for a 0b or 0B prefix on binary constants as
   inputs to strtol-family functions (base 0 or 2).  This macro is
   used to condition redirection in headers to allow that redirection
   to be disabled when building those functions, despite _GNU_SOURCE
   being defined.  */
#        if __GLIBC_USE(ISOC2X)
#          define __GLIBC_USE_C2X_STRTOL 1
#        else
#          define __GLIBC_USE_C2X_STRTOL 0
#        endif

/* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  */
/* Copyright (C) 1991-2023 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

#        ifndef _STDC_PREDEF_H
#          define _STDC_PREDEF_H 1

/* This header is separate from features.h so that the compiler can
   include it implicitly at the start of every compilation.  It must
   not itself include <features.h> or any other header that includes
   <features.h> because the implicit include comes before any feature
   test macros that may be defined in a source file before it first
   explicitly includes a system header.  GCC knows the name of this
   header in order to preinclude it.  */

/* glibc's intent is to support the IEC 559 math functionality, real
   and complex.  If the GCC (4.9 and later) predefined macros
   specifying compiler intent are available, use them to determine
   whether the overall intent is to support these features; otherwise,
   presume an older compiler has intent to support these features and
   define these macros by default.  */

#          ifdef __GCC_IEC_559
#            if __GCC_IEC_559 > 0
#              define __STDC_IEC_559__       1
#              define __STDC_IEC_60559_BFP__ 201404L
#            endif
#          else
#            define __STDC_IEC_559__       1
#            define __STDC_IEC_60559_BFP__ 201404L
#          endif

#          ifdef __GCC_IEC_559_COMPLEX
#            if __GCC_IEC_559_COMPLEX > 0
#              define __STDC_IEC_559_COMPLEX__   1
#              define __STDC_IEC_60559_COMPLEX__ 201404L
#            endif
#          else
#            define __STDC_IEC_559_COMPLEX__   1
#            define __STDC_IEC_60559_COMPLEX__ 201404L
#          endif

/* wchar_t uses Unicode 10.0.0.  Version 10.0 of the Unicode Standard is
   synchronized with ISO/IEC 10646:2017, fifth edition, plus
   the following additions from Amendment 1 to the fifth edition:
   - 56 emoji characters
   - 285 hentaigana
   - 3 additional Zanabazar Square characters */
#          define __STDC_ISO_10646__ 201706L

#        endif

/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */
#        undef __GNU_LIBRARY__
#        define __GNU_LIBRARY__ 6

/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */
#        define __GLIBC__       2
#        define __GLIBC_MINOR__ 38

#        define __GLIBC_PREREQ(maj, min)                                                           \
          ((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))

/* This is here only because every header file already includes this one.  */
#        ifndef __ASSEMBLER__
#          ifndef _SYS_CDEFS_H
// #            include <sys/cdefs.h>
#          endif

/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */
#          if defined __USE_FILE_OFFSET64 && !defined __REDIRECT
#            define __USE_LARGEFILE   1
#            define __USE_LARGEFILE64 1
#          endif

#        endif /* !ASSEMBLER */

/* Decide whether we can define 'extern inline' functions in headers.  */
#        if __GNUC_PREREQ(2, 7) && defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__ &&           \
            !defined __NO_INLINE__ && defined __extern_inline
#          define __USE_EXTERN_INLINES 1
#        endif

/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
// #        include <gnu/stubs.h>

#      endif /* features.h  */

// Provide a declaration for the possibly deprecated gets function, as
// glibc 2.15 and later does not declare gets for ISO C11 when
// __GNU_SOURCE is defined.
#      if __GLIBC_PREREQ(2, 15) && defined(_GNU_SOURCE)
#        undef _GLIBCXX_HAVE_GETS
#      endif

// Glibc 2.23 removed the obsolete isinf and isnan declarations. Check the
// version dynamically in case it has changed since libstdc++ was configured.
#      define _GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC __GLIBC_PREREQ(2, 23)

// Glibc 2.26 on i?86/x86-64/ia64/ppc64le added *f128 support.
// Glibc 2.27 added it also on many other arches but those have IEEE quad
// long double.
#      if __GLIBC_PREREQ(2, 26) &&                                                                 \
          (defined(__i386__) || defined(__x86_64__) || defined(__ia64__) ||                        \
           (defined(__powerpc__) && defined(_ARCH_PWR8) && defined(__LITTLE_ENDIAN__) &&           \
            (_CALL_ELF == 2) && defined(__FLOAT128__)))
#        define _GLIBCXX_HAVE_FLOAT128_MATH 1
#      endif

#      ifdef __linux__
// The following libpthread properties only apply to Linux, not GNU/Hurd.

#        if __GLIBC_PREREQ(2, 27)
// Since glibc 2.27 pthread_self() is usable without linking to libpthread.
#          define _GLIBCXX_NATIVE_THREAD_ID pthread_self()
#        else
// Before then it was in libc.so.6 but not libc.a, and always returns 0,
// which breaks the invariant this_thread::get_id() != thread::id{}.
// So only use it if we know the libpthread version is available.
// Otherwise use (__gthread_t)1 as the ID of the main (and only) thread.
#          define _GLIBCXX_NATIVE_THREAD_ID                                                        \
            (__gthread_active_p() ? __gthread_self() : (__gthread_t)1)
#        endif

#        if __GLIBC_PREREQ(2, 34)
// Since glibc 2.34 all pthreads functions are usable without linking to
// libpthread.
#          define _GLIBCXX_GTHREAD_USE_WEAK 0
#        endif

#        if defined(_TIME_BITS)
#          if _TIME_BITS == 64
#            undef _GLIBCXX_TIME_BITS64_ABI_TAG
#            define _GLIBCXX_TIME_BITS64_ABI_TAG [[__gnu__::__abi_tag__("__time64")]]
#          endif
#        endif
#      endif // __linux__

#    endif

// Pick up any CPU-specific definitions.
// Specific definitions for generic platforms  -*- C++ -*-

// Copyright (C) 2005-2023 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/cpu_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */

#    ifndef _GLIBCXX_CPU_DEFINES
#      define _GLIBCXX_CPU_DEFINES 1

#    endif

// If platform uses neither visibility nor psuedo-visibility,
// specify empty default for namespace annotation macros.
#    ifndef _GLIBCXX_PSEUDO_VISIBILITY
#      define _GLIBCXX_PSEUDO_VISIBILITY(V)
#    endif

// Certain function definitions that are meant to be overridable from
// user code are decorated with this macro.  For some targets, this
// macro causes these definitions to be weak.
#    ifndef _GLIBCXX_WEAK_DEFINITION
#      define _GLIBCXX_WEAK_DEFINITION
#    endif

// By default, we assume that __GXX_WEAK__ also means that there is support
// for declaring functions as weak while not defining such functions.  This
// allows for referring to functions provided by other libraries (e.g.,
// libitm) without depending on them if the respective features are not used.
#    ifndef _GLIBCXX_USE_WEAK_REF
#      define _GLIBCXX_USE_WEAK_REF __GXX_WEAK__
#    endif

// Conditionally enable annotations for the Transactional Memory TS on C++11.
// Most of the following conditions are due to limitations in the current
// implementation.
#    if __cplusplus >= 201103L && _GLIBCXX_USE_CXX11_ABI && _GLIBCXX_USE_DUAL_ABI &&               \
        __cpp_transactional_memory >= 201500L && !_GLIBCXX_FULLY_DYNAMIC_STRING &&                 \
        _GLIBCXX_USE_WEAK_REF && _GLIBCXX_USE_ALLOCATOR_NEW
#      define _GLIBCXX_TXN_SAFE     transaction_safe
#      define _GLIBCXX_TXN_SAFE_DYN transaction_safe_dynamic
#    else
#      define _GLIBCXX_TXN_SAFE
#      define _GLIBCXX_TXN_SAFE_DYN
#    endif

#    if __cplusplus > 201402L
// In C++17 mathematical special functions are in namespace std.
#      define _GLIBCXX_USE_STD_SPEC_FUNCS 1
#    elif __cplusplus >= 201103L && __STDCPP_WANT_MATH_SPEC_FUNCS__ != 0
// For C++11 and C++14 they are in namespace std when requested.
#      define _GLIBCXX_USE_STD_SPEC_FUNCS 1
#    endif

// The remainder of the prewritten config is automatic; all the
// user hooks are listed above.

// Create a boolean flag to be used to determine if --fast-math is set.
#    ifdef __FAST_MATH__
#      define _GLIBCXX_FAST_MATH 1
#    else
#      define _GLIBCXX_FAST_MATH 0
#    endif

// This marks string literals in header files to be extracted for eventual
// translation.  It is primarily used for messages in thrown exceptions; see
// src/functexcept.cc.  We use __N because the more traditional _N is used
// for something else under certain OSes (see BADNAMES).
#    define __N(msgid) (msgid)

// For example, <windows.h> is known to #define min and max as macros...
#    undef min
#    undef max

// N.B. these _GLIBCXX_USE_C99_XXX macros are defined unconditionally
// so they should be tested with #if not with #ifdef.
#    if __cplusplus >= 201103L
#      ifndef _GLIBCXX_USE_C99_MATH
#        define _GLIBCXX_USE_C99_MATH _GLIBCXX11_USE_C99_MATH
#      endif
#      ifndef _GLIBCXX_USE_C99_COMPLEX
#        define _GLIBCXX_USE_C99_COMPLEX _GLIBCXX11_USE_C99_COMPLEX
#      endif
#      ifndef _GLIBCXX_USE_C99_STDIO
#        define _GLIBCXX_USE_C99_STDIO _GLIBCXX11_USE_C99_STDIO
#      endif
#      ifndef _GLIBCXX_USE_C99_STDLIB
#        define _GLIBCXX_USE_C99_STDLIB _GLIBCXX11_USE_C99_STDLIB
#      endif
#      ifndef _GLIBCXX_USE_C99_WCHAR
#        define _GLIBCXX_USE_C99_WCHAR _GLIBCXX11_USE_C99_WCHAR
#      endif
#    else
#      ifndef _GLIBCXX_USE_C99_MATH
#        define _GLIBCXX_USE_C99_MATH _GLIBCXX98_USE_C99_MATH
#      endif
#      ifndef _GLIBCXX_USE_C99_COMPLEX
#        define _GLIBCXX_USE_C99_COMPLEX _GLIBCXX98_USE_C99_COMPLEX
#      endif
#      ifndef _GLIBCXX_USE_C99_STDIO
#        define _GLIBCXX_USE_C99_STDIO _GLIBCXX98_USE_C99_STDIO
#      endif
#      ifndef _GLIBCXX_USE_C99_STDLIB
#        define _GLIBCXX_USE_C99_STDLIB _GLIBCXX98_USE_C99_STDLIB
#      endif
#      ifndef _GLIBCXX_USE_C99_WCHAR
#        define _GLIBCXX_USE_C99_WCHAR _GLIBCXX98_USE_C99_WCHAR
#      endif
#    endif

// Unless explicitly specified, enable char8_t extensions only if the core
// language char8_t feature macro is defined.
#    ifndef _GLIBCXX_USE_CHAR8_T
#      ifdef __cpp_char8_t
#        define _GLIBCXX_USE_CHAR8_T 1
#      endif
#    endif
#    ifdef _GLIBCXX_USE_CHAR8_T
#      define __cpp_lib_char8_t 201907L
#    endif

/* Define if __float128 is supported on this host.  */
#    if defined(__FLOAT128__) || defined(__SIZEOF_FLOAT128__)
/* For powerpc64 don't use __float128 when it's the same type as long double. */
#      if !(defined(_GLIBCXX_LONG_DOUBLE_ALT128_COMPAT) && defined(__LONG_DOUBLE_IEEE128__))
#        define _GLIBCXX_USE_FLOAT128 1
#      endif
#    endif

// Define if float has the IEEE binary32 format.
#    if __FLT_MANT_DIG__ == 24 && __FLT_MIN_EXP__ == -125 && __FLT_MAX_EXP__ == 128
#      define _GLIBCXX_FLOAT_IS_IEEE_BINARY32 1
#    endif

// Define if double has the IEEE binary64 format.
#    if __DBL_MANT_DIG__ == 53 && __DBL_MIN_EXP__ == -1021 && __DBL_MAX_EXP__ == 1024
#      define _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 1
#    endif

// Define if long double has the IEEE binary128 format.
#    if __LDBL_MANT_DIG__ == 113 && __LDBL_MIN_EXP__ == -16381 && __LDBL_MAX_EXP__ == 16384
#      define _GLIBCXX_LDOUBLE_IS_IEEE_BINARY128 1
#    endif

#    ifdef __STDCPP_BFLOAT16_T__
namespace __gnu_cxx {
using __bfloat16_t = decltype(0.0bf16);
}
#    endif

#    ifdef __has_builtin
#      ifdef __is_identifier
// Intel and older Clang require !__is_identifier for some built-ins:
#        define _GLIBCXX_HAS_BUILTIN(B) __has_builtin(B) || !__is_identifier(B)
#      else
#        define _GLIBCXX_HAS_BUILTIN(B) __has_builtin(B)
#      endif
#    endif

#    if _GLIBCXX_HAS_BUILTIN(__has_unique_object_representations)
#      define _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP 1
#    endif

#    if _GLIBCXX_HAS_BUILTIN(__is_aggregate)
#      define _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE 1
#    endif

#    if _GLIBCXX_HAS_BUILTIN(__is_same)
#      define _GLIBCXX_HAVE_BUILTIN_IS_SAME 1
#    endif

#    if _GLIBCXX_HAS_BUILTIN(__builtin_launder)
#      define _GLIBCXX_HAVE_BUILTIN_LAUNDER 1
#    endif

#    undef _GLIBCXX_HAS_BUILTIN

// Mark code that should be ignored by the compiler, but seen by Doxygen.
#    define _GLIBCXX_DOXYGEN_ONLY(X)

// PSTL configuration

#    if __cplusplus >= 201703L
// This header is not installed for freestanding:
#      if __has_include(<pstl/pstl_config.h>)
// Preserved here so we have some idea which version of upstream we've pulled in
// #define PSTL_VERSION 9000

// For now this defaults to being based on the presence of Thread Building Blocks
#        ifndef _GLIBCXX_USE_TBB_PAR_BACKEND
#          define _GLIBCXX_USE_TBB_PAR_BACKEND __has_include(<tbb/tbb.h>)
#        endif
// This section will need some rework when a new (default) backend type is added
#        if _GLIBCXX_USE_TBB_PAR_BACKEND
#          define _PSTL_PAR_BACKEND_TBB
#        else
#          define _PSTL_PAR_BACKEND_SERIAL
#        endif

#        define _PSTL_ASSERT(_Condition)               __glibcxx_assert(_Condition)
#        define _PSTL_ASSERT_MSG(_Condition, _Message) __glibcxx_assert(_Condition)

#        include <pstl/pstl_config.h>
#      endif // __has_include
#    endif   // C++17

#    define _GLIBCXX_TIME_BITS64_ABI_TAG

// End of prewritten config; the settings discovered at configure time follow.
/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define to 1 if you have the `acosf' function. */
#    define _GLIBCXX_HAVE_ACOSF                                  1

/* Define to 1 if you have the `acosl' function. */
#    define _GLIBCXX_HAVE_ACOSL                                  1

/* Define to 1 if you have the `aligned_alloc' function. */
#    define _GLIBCXX_HAVE_ALIGNED_ALLOC                          1

/* Define if arc4random is available in <stdlib.h>. */
#    define _GLIBCXX_HAVE_ARC4RANDOM                             1

/* Define to 1 if you have the <arpa/inet.h> header file. */
#    define _GLIBCXX_HAVE_ARPA_INET_H                            1

/* Define to 1 if you have the `asinf' function. */
#    define _GLIBCXX_HAVE_ASINF                                  1

/* Define to 1 if you have the `asinl' function. */
#    define _GLIBCXX_HAVE_ASINL                                  1

/* Define to 1 if the target assembler supports .symver directive. */
#    define _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE                    1

/* Define to 1 if you have the `atan2f' function. */
#    define _GLIBCXX_HAVE_ATAN2F                                 1

/* Define to 1 if you have the `atan2l' function. */
#    define _GLIBCXX_HAVE_ATAN2L                                 1

/* Define to 1 if you have the `atanf' function. */
#    define _GLIBCXX_HAVE_ATANF                                  1

/* Define to 1 if you have the `atanl' function. */
#    define _GLIBCXX_HAVE_ATANL                                  1

/* Defined if shared_ptr reference counting should use atomic operations. */
#    define _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY                     1

/* Define to 1 if you have the `at_quick_exit' function. */
#    define _GLIBCXX_HAVE_AT_QUICK_EXIT                          1

/* Define to 1 if the target assembler supports thread-local storage. */
/* #undef _GLIBCXX_HAVE_CC_TLS */

/* Define to 1 if you have the `ceilf' function. */
#    define _GLIBCXX_HAVE_CEILF                                  1

/* Define to 1 if you have the `ceill' function. */
#    define _GLIBCXX_HAVE_CEILL                                  1

/* Define to 1 if you have the <complex.h> header file. */
#    define _GLIBCXX_HAVE_COMPLEX_H                              1

/* Define to 1 if you have the `cosf' function. */
#    define _GLIBCXX_HAVE_COSF                                   1

/* Define to 1 if you have the `coshf' function. */
#    define _GLIBCXX_HAVE_COSHF                                  1

/* Define to 1 if you have the `coshl' function. */
#    define _GLIBCXX_HAVE_COSHL                                  1

/* Define to 1 if you have the `cosl' function. */
#    define _GLIBCXX_HAVE_COSL                                   1

/* Define to 1 if you have the declaration of `strnlen', and to 0 if you
   don't. */
#    define _GLIBCXX_HAVE_DECL_STRNLEN                           1

/* Define to 1 if you have the <dirent.h> header file. */
#    define _GLIBCXX_HAVE_DIRENT_H                               1

/* Define if dirfd is available in <dirent.h>. */
#    define _GLIBCXX_HAVE_DIRFD                                  1

/* Define to 1 if you have the <dlfcn.h> header file. */
#    define _GLIBCXX_HAVE_DLFCN_H                                1

/* Define to 1 if you have the <endian.h> header file. */
#    define _GLIBCXX_HAVE_ENDIAN_H                               1

/* Define to 1 if GCC 4.6 supported std::exception_ptr for the target */
#    define _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46              1

/* Define to 1 if you have the <execinfo.h> header file. */
#    define _GLIBCXX_HAVE_EXECINFO_H                             1

/* Define to 1 if you have the `expf' function. */
#    define _GLIBCXX_HAVE_EXPF                                   1

/* Define to 1 if you have the `expl' function. */
#    define _GLIBCXX_HAVE_EXPL                                   1

/* Define to 1 if you have the `fabsf' function. */
#    define _GLIBCXX_HAVE_FABSF                                  1

/* Define to 1 if you have the `fabsl' function. */
#    define _GLIBCXX_HAVE_FABSL                                  1

/* Define to 1 if you have the <fcntl.h> header file. */
#    define _GLIBCXX_HAVE_FCNTL_H                                1

/* Define if fdopendir is available in <dirent.h>. */
#    define _GLIBCXX_HAVE_FDOPENDIR                              1

/* Define to 1 if you have the <fenv.h> header file. */
#    define _GLIBCXX_HAVE_FENV_H                                 1

/* Define to 1 if you have the `finite' function. */
#    define _GLIBCXX_HAVE_FINITE                                 1

/* Define to 1 if you have the `finitef' function. */
#    define _GLIBCXX_HAVE_FINITEF                                1

/* Define to 1 if you have the `finitel' function. */
#    define _GLIBCXX_HAVE_FINITEL                                1

/* Define to 1 if you have the <float.h> header file. */
#    define _GLIBCXX_HAVE_FLOAT_H                                1

/* Define to 1 if you have the `floorf' function. */
#    define _GLIBCXX_HAVE_FLOORF                                 1

/* Define to 1 if you have the `floorl' function. */
#    define _GLIBCXX_HAVE_FLOORL                                 1

/* Define to 1 if you have the `fmodf' function. */
#    define _GLIBCXX_HAVE_FMODF                                  1

/* Define to 1 if you have the `fmodl' function. */
#    define _GLIBCXX_HAVE_FMODL                                  1

/* Define to 1 if you have the `fpclass' function. */
/* #undef _GLIBCXX_HAVE_FPCLASS */

/* Define to 1 if you have the <fp.h> header file. */
/* #undef _GLIBCXX_HAVE_FP_H */

/* Define to 1 if you have the `frexpf' function. */
#    define _GLIBCXX_HAVE_FREXPF                                 1

/* Define to 1 if you have the `frexpl' function. */
#    define _GLIBCXX_HAVE_FREXPL                                 1

/* Define if getentropy is available in <unistd.h>. */
#    define _GLIBCXX_HAVE_GETENTROPY                             1

/* Define if _Unwind_GetIPInfo is available. */
#    define _GLIBCXX_HAVE_GETIPINFO                              1

/* Define if gets is available in <stdio.h> before C++14. */
#    define _GLIBCXX_HAVE_GETS                                   1

/* Define to 1 if you have the `hypot' function. */
#    define _GLIBCXX_HAVE_HYPOT                                  1

/* Define to 1 if you have the `hypotf' function. */
#    define _GLIBCXX_HAVE_HYPOTF                                 1

/* Define to 1 if you have the `hypotl' function. */
#    define _GLIBCXX_HAVE_HYPOTL                                 1

/* Define if you have the iconv() function. */
#    define _GLIBCXX_HAVE_ICONV                                  1

/* Define to 1 if you have the <ieeefp.h> header file. */
/* #undef _GLIBCXX_HAVE_IEEEFP_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#    define _GLIBCXX_HAVE_INTTYPES_H                             1

/* Define to 1 if you have the `isinf' function. */
/* #undef _GLIBCXX_HAVE_ISINF */

/* Define to 1 if you have the `isinff' function. */
#    define _GLIBCXX_HAVE_ISINFF                                 1

/* Define to 1 if you have the `isinfl' function. */
#    define _GLIBCXX_HAVE_ISINFL                                 1

/* Define to 1 if you have the `isnan' function. */
/* #undef _GLIBCXX_HAVE_ISNAN */

/* Define to 1 if you have the `isnanf' function. */
#    define _GLIBCXX_HAVE_ISNANF                                 1

/* Define to 1 if you have the `isnanl' function. */
#    define _GLIBCXX_HAVE_ISNANL                                 1

/* Defined if iswblank exists. */
#    define _GLIBCXX_HAVE_ISWBLANK                               1

/* Define if LC_MESSAGES is available in <locale.h>. */
#    define _GLIBCXX_HAVE_LC_MESSAGES                            1

/* Define to 1 if you have the `ldexpf' function. */
#    define _GLIBCXX_HAVE_LDEXPF                                 1

/* Define to 1 if you have the `ldexpl' function. */
#    define _GLIBCXX_HAVE_LDEXPL                                 1

/* Define to 1 if you have the <libintl.h> header file. */
#    define _GLIBCXX_HAVE_LIBINTL_H                              1

/* Only used in build directory testsuite_hooks.h. */
#    define _GLIBCXX_HAVE_LIMIT_AS                               1

/* Only used in build directory testsuite_hooks.h. */
#    define _GLIBCXX_HAVE_LIMIT_DATA                             1

/* Only used in build directory testsuite_hooks.h. */
#    define _GLIBCXX_HAVE_LIMIT_FSIZE                            1

/* Only used in build directory testsuite_hooks.h. */
#    define _GLIBCXX_HAVE_LIMIT_RSS                              1

/* Only used in build directory testsuite_hooks.h. */
#    define _GLIBCXX_HAVE_LIMIT_VMEM                             0

/* Define if link is available in <unistd.h>. */
#    define _GLIBCXX_HAVE_LINK                                   1

/* Define to 1 if you have the <link.h> header file. */
#    define _GLIBCXX_HAVE_LINK_H                                 1

/* Define if futex syscall is available. */
#    define _GLIBCXX_HAVE_LINUX_FUTEX                            1

/* Define to 1 if you have the <linux/random.h> header file. */
#    define _GLIBCXX_HAVE_LINUX_RANDOM_H                         1

/* Define to 1 if you have the <linux/types.h> header file. */
#    define _GLIBCXX_HAVE_LINUX_TYPES_H                          1

/* Define to 1 if you have the <locale.h> header file. */
#    define _GLIBCXX_HAVE_LOCALE_H                               1

/* Define to 1 if you have the `log10f' function. */
#    define _GLIBCXX_HAVE_LOG10F                                 1

/* Define to 1 if you have the `log10l' function. */
#    define _GLIBCXX_HAVE_LOG10L                                 1

/* Define to 1 if you have the `logf' function. */
#    define _GLIBCXX_HAVE_LOGF                                   1

/* Define to 1 if you have the `logl' function. */
#    define _GLIBCXX_HAVE_LOGL                                   1

/* Define to 1 if you have the <machine/endian.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_ENDIAN_H */

/* Define to 1 if you have the <machine/param.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_PARAM_H */

/* Define if mbstate_t exists in wchar.h. */
#    define _GLIBCXX_HAVE_MBSTATE_T                              1

/* Define to 1 if you have the `memalign' function. */
#    define _GLIBCXX_HAVE_MEMALIGN                               1

/* Define to 1 if you have the <memory.h> header file. */
#    define _GLIBCXX_HAVE_MEMORY_H                               1

/* Define to 1 if you have the `modf' function. */
#    define _GLIBCXX_HAVE_MODF                                   1

/* Define to 1 if you have the `modff' function. */
#    define _GLIBCXX_HAVE_MODFF                                  1

/* Define to 1 if you have the `modfl' function. */
#    define _GLIBCXX_HAVE_MODFL                                  1

/* Define to 1 if you have the <nan.h> header file. */
/* #undef _GLIBCXX_HAVE_NAN_H */

/* Define to 1 if you have the <netdb.h> header file. */
#    define _GLIBCXX_HAVE_NETDB_H                                1

/* Define to 1 if you have the <netinet/in.h> header file. */
#    define _GLIBCXX_HAVE_NETINET_IN_H                           1

/* Define to 1 if you have the <netinet/tcp.h> header file. */
#    define _GLIBCXX_HAVE_NETINET_TCP_H                          1

/* Define if <math.h> defines obsolete isinf function. */
/* #undef _GLIBCXX_HAVE_OBSOLETE_ISINF */

/* Define if <math.h> defines obsolete isnan function. */
/* #undef _GLIBCXX_HAVE_OBSOLETE_ISNAN */

/* Define if openat is available in <fcntl.h>. */
#    define _GLIBCXX_HAVE_OPENAT                                 1

/* Define if poll is available in <poll.h>. */
#    define _GLIBCXX_HAVE_POLL                                   1

/* Define to 1 if you have the <poll.h> header file. */
#    define _GLIBCXX_HAVE_POLL_H                                 1

/* Define to 1 if you have the `posix_memalign' function. */
#    define _GLIBCXX_HAVE_POSIX_MEMALIGN                         1

/* Define to 1 if POSIX Semaphores with sem_timedwait are available in
   <semaphore.h>. */
#    define _GLIBCXX_HAVE_POSIX_SEMAPHORE                        1

/* Define to 1 if you have the `powf' function. */
#    define _GLIBCXX_HAVE_POWF                                   1

/* Define to 1 if you have the `powl' function. */
#    define _GLIBCXX_HAVE_POWL                                   1

/* Define to 1 if you have the `qfpclass' function. */
/* #undef _GLIBCXX_HAVE_QFPCLASS */

/* Define to 1 if you have the `quick_exit' function. */
#    define _GLIBCXX_HAVE_QUICK_EXIT                             1

/* Define if readlink is available in <unistd.h>. */
#    define _GLIBCXX_HAVE_READLINK                               1

/* Define to 1 if you have the `secure_getenv' function. */
#    define _GLIBCXX_HAVE_SECURE_GETENV                          1

/* Define to 1 if you have the `setenv' function. */
#    define _GLIBCXX_HAVE_SETENV                                 1

/* Define to 1 if you have the `sincos' function. */
#    define _GLIBCXX_HAVE_SINCOS                                 1

/* Define to 1 if you have the `sincosf' function. */
#    define _GLIBCXX_HAVE_SINCOSF                                1

/* Define to 1 if you have the `sincosl' function. */
#    define _GLIBCXX_HAVE_SINCOSL                                1

/* Define to 1 if you have the `sinf' function. */
#    define _GLIBCXX_HAVE_SINF                                   1

/* Define to 1 if you have the `sinhf' function. */
#    define _GLIBCXX_HAVE_SINHF                                  1

/* Define to 1 if you have the `sinhl' function. */
#    define _GLIBCXX_HAVE_SINHL                                  1

/* Define to 1 if you have the `sinl' function. */
#    define _GLIBCXX_HAVE_SINL                                   1

/* Defined if sleep exists. */
/* #undef _GLIBCXX_HAVE_SLEEP */

/* Define to 1 if you have the `sockatmark' function. */
#    define _GLIBCXX_HAVE_SOCKATMARK                             1

/* Define to 1 if you have the `sqrtf' function. */
#    define _GLIBCXX_HAVE_SQRTF                                  1

/* Define to 1 if you have the `sqrtl' function. */
#    define _GLIBCXX_HAVE_SQRTL                                  1

/* Define if the <stacktrace> header is supported. */
#    define _GLIBCXX_HAVE_STACKTRACE                             1

/* Define to 1 if you have the <stdalign.h> header file. */
#    define _GLIBCXX_HAVE_STDALIGN_H                             1

/* Define to 1 if you have the <stdbool.h> header file. */
#    define _GLIBCXX_HAVE_STDBOOL_H                              1

/* Define to 1 if you have the <stdint.h> header file. */
#    define _GLIBCXX_HAVE_STDINT_H                               1

/* Define to 1 if you have the <stdlib.h> header file. */
#    define _GLIBCXX_HAVE_STDLIB_H                               1

/* Define if strerror_l is available in <string.h>. */
#    define _GLIBCXX_HAVE_STRERROR_L                             1

/* Define if strerror_r is available in <string.h>. */
#    define _GLIBCXX_HAVE_STRERROR_R                             1

/* Define to 1 if you have the <strings.h> header file. */
#    define _GLIBCXX_HAVE_STRINGS_H                              1

/* Define to 1 if you have the <string.h> header file. */
#    define _GLIBCXX_HAVE_STRING_H                               1

/* Define to 1 if you have the `strtof' function. */
#    define _GLIBCXX_HAVE_STRTOF                                 1

/* Define to 1 if you have the `strtold' function. */
#    define _GLIBCXX_HAVE_STRTOLD                                1

/* Define to 1 if `d_type' is a member of `struct dirent'. */
#    define _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE                   1

/* Define if strxfrm_l is available in <string.h>. */
#    define _GLIBCXX_HAVE_STRXFRM_L                              1

/* Define if symlink is available in <unistd.h>. */
#    define _GLIBCXX_HAVE_SYMLINK                                1

/* Define to 1 if the target runtime linker supports binding the same symbol
   to different versions. */
#    define _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT 1

/* Define to 1 if you have the <sys/filio.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_FILIO_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#    define _GLIBCXX_HAVE_SYS_IOCTL_H                            1

/* Define to 1 if you have the <sys/ipc.h> header file. */
#    define _GLIBCXX_HAVE_SYS_IPC_H                              1

/* Define to 1 if you have the <sys/isa_defs.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_ISA_DEFS_H */

/* Define to 1 if you have the <sys/machine.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_MACHINE_H */

/* Define to 1 if you have the <sys/mman.h> header file. */
#    define _GLIBCXX_HAVE_SYS_MMAN_H                             1

/* Define to 1 if you have the <sys/param.h> header file. */
#    define _GLIBCXX_HAVE_SYS_PARAM_H                            1

/* Define to 1 if you have the <sys/resource.h> header file. */
#    define _GLIBCXX_HAVE_SYS_RESOURCE_H                         1

/* Define to 1 if you have a suitable <sys/sdt.h> header file */
#    define _GLIBCXX_HAVE_SYS_SDT_H                              1

/* Define to 1 if you have the <sys/sem.h> header file. */
#    define _GLIBCXX_HAVE_SYS_SEM_H                              1

/* Define to 1 if you have the <sys/socket.h> header file. */
#    define _GLIBCXX_HAVE_SYS_SOCKET_H                           1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#    define _GLIBCXX_HAVE_SYS_STATVFS_H                          1

/* Define to 1 if you have the <sys/stat.h> header file. */
#    define _GLIBCXX_HAVE_SYS_STAT_H                             1

/* Define to 1 if you have the <sys/sysinfo.h> header file. */
#    define _GLIBCXX_HAVE_SYS_SYSINFO_H                          1

/* Define to 1 if you have the <sys/time.h> header file. */
#    define _GLIBCXX_HAVE_SYS_TIME_H                             1

/* Define to 1 if you have the <sys/types.h> header file. */
#    define _GLIBCXX_HAVE_SYS_TYPES_H                            1

/* Define to 1 if you have the <sys/uio.h> header file. */
#    define _GLIBCXX_HAVE_SYS_UIO_H                              1

/* Define if S_IFREG is available in <sys/stat.h>. */
/* #undef _GLIBCXX_HAVE_S_IFREG */

/* Define if S_ISREG is available in <sys/stat.h>. */
#    define _GLIBCXX_HAVE_S_ISREG                                1

/* Define to 1 if you have the `tanf' function. */
#    define _GLIBCXX_HAVE_TANF                                   1

/* Define to 1 if you have the `tanhf' function. */
#    define _GLIBCXX_HAVE_TANHF                                  1

/* Define to 1 if you have the `tanhl' function. */
#    define _GLIBCXX_HAVE_TANHL                                  1

/* Define to 1 if you have the `tanl' function. */
#    define _GLIBCXX_HAVE_TANL                                   1

/* Define to 1 if you have the <tgmath.h> header file. */
#    define _GLIBCXX_HAVE_TGMATH_H                               1

/* Define to 1 if you have the `timespec_get' function. */
#    define _GLIBCXX_HAVE_TIMESPEC_GET                           1

/* Define to 1 if the target supports thread-local storage. */
#    define _GLIBCXX_HAVE_TLS                                    1

/* Define if truncate is available in <unistd.h>. */
#    define _GLIBCXX_HAVE_TRUNCATE                               1

/* Define to 1 if you have the <uchar.h> header file. */
#    define _GLIBCXX_HAVE_UCHAR_H                                1

/* Define to 1 if you have the <unistd.h> header file. */
#    define _GLIBCXX_HAVE_UNISTD_H                               1

/* Define if unlinkat is available in <fcntl.h>. */
#    define _GLIBCXX_HAVE_UNLINKAT                               1

/* Define to 1 if you have the `uselocale' function. */
#    define _GLIBCXX_HAVE_USELOCALE                              1

/* Defined if usleep exists. */
/* #undef _GLIBCXX_HAVE_USLEEP */

/* Define to 1 if you have the <utime.h> header file. */
#    define _GLIBCXX_HAVE_UTIME_H                                1

/* Defined if vfwscanf exists. */
#    define _GLIBCXX_HAVE_VFWSCANF                               1

/* Defined if vswscanf exists. */
#    define _GLIBCXX_HAVE_VSWSCANF                               1

/* Defined if vwscanf exists. */
#    define _GLIBCXX_HAVE_VWSCANF                                1

/* Define to 1 if you have the <wchar.h> header file. */
#    define _GLIBCXX_HAVE_WCHAR_H                                1

/* Defined if wcstof exists. */
#    define _GLIBCXX_HAVE_WCSTOF                                 1

/* Define to 1 if you have the <wctype.h> header file. */
#    define _GLIBCXX_HAVE_WCTYPE_H                               1

/* Define to 1 if you have the <windows.h> header file. */
/* #undef _GLIBCXX_HAVE_WINDOWS_H */

/* Define if writev is available in <sys/uio.h>. */
#    define _GLIBCXX_HAVE_WRITEV                                 1

/* Define to 1 if you have the <xlocale.h> header file. */
/* #undef _GLIBCXX_HAVE_XLOCALE_H */

/* Define to 1 if you have the `_acosf' function. */
/* #undef _GLIBCXX_HAVE__ACOSF */

/* Define to 1 if you have the `_acosl' function. */
/* #undef _GLIBCXX_HAVE__ACOSL */

/* Define to 1 if you have the `_aligned_malloc' function. */
/* #undef _GLIBCXX_HAVE__ALIGNED_MALLOC */

/* Define to 1 if you have the `_asinf' function. */
/* #undef _GLIBCXX_HAVE__ASINF */

/* Define to 1 if you have the `_asinl' function. */
/* #undef _GLIBCXX_HAVE__ASINL */

/* Define to 1 if you have the `_atan2f' function. */
/* #undef _GLIBCXX_HAVE__ATAN2F */

/* Define to 1 if you have the `_atan2l' function. */
/* #undef _GLIBCXX_HAVE__ATAN2L */

/* Define to 1 if you have the `_atanf' function. */
/* #undef _GLIBCXX_HAVE__ATANF */

/* Define to 1 if you have the `_atanl' function. */
/* #undef _GLIBCXX_HAVE__ATANL */

/* Define to 1 if you have the `_ceilf' function. */
/* #undef _GLIBCXX_HAVE__CEILF */

/* Define to 1 if you have the `_ceill' function. */
/* #undef _GLIBCXX_HAVE__CEILL */

/* Define to 1 if you have the `_cosf' function. */
/* #undef _GLIBCXX_HAVE__COSF */

/* Define to 1 if you have the `_coshf' function. */
/* #undef _GLIBCXX_HAVE__COSHF */

/* Define to 1 if you have the `_coshl' function. */
/* #undef _GLIBCXX_HAVE__COSHL */

/* Define to 1 if you have the `_cosl' function. */
/* #undef _GLIBCXX_HAVE__COSL */

/* Define to 1 if you have the `_expf' function. */
/* #undef _GLIBCXX_HAVE__EXPF */

/* Define to 1 if you have the `_expl' function. */
/* #undef _GLIBCXX_HAVE__EXPL */

/* Define to 1 if you have the `_fabsf' function. */
/* #undef _GLIBCXX_HAVE__FABSF */

/* Define to 1 if you have the `_fabsl' function. */
/* #undef _GLIBCXX_HAVE__FABSL */

/* Define to 1 if you have the `_finite' function. */
/* #undef _GLIBCXX_HAVE__FINITE */

/* Define to 1 if you have the `_finitef' function. */
/* #undef _GLIBCXX_HAVE__FINITEF */

/* Define to 1 if you have the `_finitel' function. */
/* #undef _GLIBCXX_HAVE__FINITEL */

/* Define to 1 if you have the `_floorf' function. */
/* #undef _GLIBCXX_HAVE__FLOORF */

/* Define to 1 if you have the `_floorl' function. */
/* #undef _GLIBCXX_HAVE__FLOORL */

/* Define to 1 if you have the `_fmodf' function. */
/* #undef _GLIBCXX_HAVE__FMODF */

/* Define to 1 if you have the `_fmodl' function. */
/* #undef _GLIBCXX_HAVE__FMODL */

/* Define to 1 if you have the `_fpclass' function. */
/* #undef _GLIBCXX_HAVE__FPCLASS */

/* Define to 1 if you have the `_frexpf' function. */
/* #undef _GLIBCXX_HAVE__FREXPF */

/* Define to 1 if you have the `_frexpl' function. */
/* #undef _GLIBCXX_HAVE__FREXPL */

/* Define to 1 if you have the `_hypot' function. */
/* #undef _GLIBCXX_HAVE__HYPOT */

/* Define to 1 if you have the `_hypotf' function. */
/* #undef _GLIBCXX_HAVE__HYPOTF */

/* Define to 1 if you have the `_hypotl' function. */
/* #undef _GLIBCXX_HAVE__HYPOTL */

/* Define to 1 if you have the `_isinf' function. */
/* #undef _GLIBCXX_HAVE__ISINF */

/* Define to 1 if you have the `_isinff' function. */
/* #undef _GLIBCXX_HAVE__ISINFF */

/* Define to 1 if you have the `_isinfl' function. */
/* #undef _GLIBCXX_HAVE__ISINFL */

/* Define to 1 if you have the `_isnan' function. */
/* #undef _GLIBCXX_HAVE__ISNAN */

/* Define to 1 if you have the `_isnanf' function. */
/* #undef _GLIBCXX_HAVE__ISNANF */

/* Define to 1 if you have the `_isnanl' function. */
/* #undef _GLIBCXX_HAVE__ISNANL */

/* Define to 1 if you have the `_ldexpf' function. */
/* #undef _GLIBCXX_HAVE__LDEXPF */

/* Define to 1 if you have the `_ldexpl' function. */
/* #undef _GLIBCXX_HAVE__LDEXPL */

/* Define to 1 if you have the `_log10f' function. */
/* #undef _GLIBCXX_HAVE__LOG10F */

/* Define to 1 if you have the `_log10l' function. */
/* #undef _GLIBCXX_HAVE__LOG10L */

/* Define to 1 if you have the `_logf' function. */
/* #undef _GLIBCXX_HAVE__LOGF */

/* Define to 1 if you have the `_logl' function. */
/* #undef _GLIBCXX_HAVE__LOGL */

/* Define to 1 if you have the `_modf' function. */
/* #undef _GLIBCXX_HAVE__MODF */

/* Define to 1 if you have the `_modff' function. */
/* #undef _GLIBCXX_HAVE__MODFF */

/* Define to 1 if you have the `_modfl' function. */
/* #undef _GLIBCXX_HAVE__MODFL */

/* Define to 1 if you have the `_powf' function. */
/* #undef _GLIBCXX_HAVE__POWF */

/* Define to 1 if you have the `_powl' function. */
/* #undef _GLIBCXX_HAVE__POWL */

/* Define to 1 if you have the `_qfpclass' function. */
/* #undef _GLIBCXX_HAVE__QFPCLASS */

/* Define to 1 if you have the `_sincos' function. */
/* #undef _GLIBCXX_HAVE__SINCOS */

/* Define to 1 if you have the `_sincosf' function. */
/* #undef _GLIBCXX_HAVE__SINCOSF */

/* Define to 1 if you have the `_sincosl' function. */
/* #undef _GLIBCXX_HAVE__SINCOSL */

/* Define to 1 if you have the `_sinf' function. */
/* #undef _GLIBCXX_HAVE__SINF */

/* Define to 1 if you have the `_sinhf' function. */
/* #undef _GLIBCXX_HAVE__SINHF */

/* Define to 1 if you have the `_sinhl' function. */
/* #undef _GLIBCXX_HAVE__SINHL */

/* Define to 1 if you have the `_sinl' function. */
/* #undef _GLIBCXX_HAVE__SINL */

/* Define to 1 if you have the `_sqrtf' function. */
/* #undef _GLIBCXX_HAVE__SQRTF */

/* Define to 1 if you have the `_sqrtl' function. */
/* #undef _GLIBCXX_HAVE__SQRTL */

/* Define to 1 if you have the `_tanf' function. */
/* #undef _GLIBCXX_HAVE__TANF */

/* Define to 1 if you have the `_tanhf' function. */
/* #undef _GLIBCXX_HAVE__TANHF */

/* Define to 1 if you have the `_tanhl' function. */
/* #undef _GLIBCXX_HAVE__TANHL */

/* Define to 1 if you have the `_tanl' function. */
/* #undef _GLIBCXX_HAVE__TANL */

/* Define to 1 if you have the `_wfopen' function. */
/* #undef _GLIBCXX_HAVE__WFOPEN */

/* Define to 1 if you have the `__cxa_thread_atexit' function. */
/* #undef _GLIBCXX_HAVE___CXA_THREAD_ATEXIT */

/* Define to 1 if you have the `__cxa_thread_atexit_impl' function. */
#    define _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL               1

/* Define as const if the declaration of iconv() needs const. */
#    define _GLIBCXX_ICONV_CONST

/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#    define _GLIBCXX_LT_OBJDIR                ".libs/"

/* Name of package */
/* #undef _GLIBCXX_PACKAGE */

/* Define to the address where bug reports for this package should be sent. */
#    define _GLIBCXX_PACKAGE_BUGREPORT        ""

/* Define to the full name of this package. */
#    define _GLIBCXX_PACKAGE_NAME             "package-unused"

/* Define to the full name and version of this package. */
#    define _GLIBCXX_PACKAGE_STRING           "package-unused version-unused"

/* Define to the one symbol short name of this package. */
#    define _GLIBCXX_PACKAGE_TARNAME          "libstdc++"

/* Define to the home page for this package. */
#    define _GLIBCXX_PACKAGE_URL              ""

/* Define to the version of this package. */
#    define _GLIBCXX_PACKAGE__GLIBCXX_VERSION "version-unused"

/* Define to 1 if you have the ANSI C header files. */
#    define _GLIBCXX_STDC_HEADERS             1

/* Version number of package */
/* #undef _GLIBCXX_VERSION */

/* Enable large inode numbers on Mac OS X 10.5.  */
#    ifndef _GLIBCXX_DARWIN_USE_64_BIT_INODE
#      define _GLIBCXX_DARWIN_USE_64_BIT_INODE 1
#    endif

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _GLIBCXX_FILE_OFFSET_BITS */

/* Define if C99 functions in <complex.h> should be used in <complex> for
   C++11. Using compiler builtins for these functions requires corresponding
   C99 library functions to be present. */
#    define _GLIBCXX11_USE_C99_COMPLEX                  1

/* Define if C99 functions or macros in <math.h> should be imported in <cmath>
   in namespace std for C++11. */
#    define _GLIBCXX11_USE_C99_MATH                     1

/* Define if C99 functions or macros in <stdio.h> should be imported in
   <cstdio> in namespace std for C++11. */
#    define _GLIBCXX11_USE_C99_STDIO                    1

/* Define if C99 functions or macros in <stdlib.h> should be imported in
   <cstdlib> in namespace std for C++11. */
#    define _GLIBCXX11_USE_C99_STDLIB                   1

/* Define if C99 functions or macros in <wchar.h> should be imported in
   <cwchar> in namespace std for C++11. */
#    define _GLIBCXX11_USE_C99_WCHAR                    1

/* Define if C99 functions in <complex.h> should be used in <complex> for
   C++98. Using compiler builtins for these functions requires corresponding
   C99 library functions to be present. */
#    define _GLIBCXX98_USE_C99_COMPLEX                  1

/* Define if C99 functions or macros in <math.h> should be imported in <cmath>
   in namespace std for C++98. */
#    define _GLIBCXX98_USE_C99_MATH                     1

/* Define if C99 functions or macros in <stdio.h> should be imported in
   <cstdio> in namespace std for C++98. */
#    define _GLIBCXX98_USE_C99_STDIO                    1

/* Define if C99 functions or macros in <stdlib.h> should be imported in
   <cstdlib> in namespace std for C++98. */
#    define _GLIBCXX98_USE_C99_STDLIB                   1

/* Define if C99 functions or macros in <wchar.h> should be imported in
   <cwchar> in namespace std for C++98. */
#    define _GLIBCXX98_USE_C99_WCHAR                    1

/* Define if the compiler supports C++11 atomics. */
#    define _GLIBCXX_ATOMIC_BUILTINS                    1

/* Define if global objects can be aligned to
   std::hardware_destructive_interference_size. */
#    define _GLIBCXX_CAN_ALIGNAS_DESTRUCTIVE_SIZE       1

/* Define to use concept checking code from the boost libraries. */
/* #undef _GLIBCXX_CONCEPT_CHECKS */

/* Define to 1 if a fully dynamic basic_string is wanted, 0 to disable,
   undefined for platform defaults */
#    define _GLIBCXX_FULLY_DYNAMIC_STRING               0

/* Define if gthreads library is available. */
#    define _GLIBCXX_HAS_GTHREADS                       1

/* Define to 1 if a full hosted library is built, or 0 if freestanding. */
#    define _GLIBCXX_HOSTED                             __STDC_HOSTED__

/* Define if compatibility should be provided for alternative 128-bit long
   double formats. */

/* Define if compatibility should be provided for -mlong-double-64. */

/* Define to the letter to which size_t is mangled. */
#    define _GLIBCXX_MANGLE_SIZE_T                      m

/* Define if C99 llrint and llround functions are missing from <math.h>. */
/* #undef _GLIBCXX_NO_C99_ROUNDING_FUNCS */

/* Defined if no way to sleep is available. */
/* #undef _GLIBCXX_NO_SLEEP */

/* Define if ptrdiff_t is int. */
/* #undef _GLIBCXX_PTRDIFF_T_IS_INT */

/* Define if using setrlimit to set resource limits during "make check" */
#    define _GLIBCXX_RES_LIMITS                         1

/* Define if size_t is unsigned int. */
/* #undef _GLIBCXX_SIZE_T_IS_UINT */

/* Define if static tzdata should be compiled into the library. */
#    define _GLIBCXX_STATIC_TZDATA                      1

/* Define to the value of the EOF integer constant. */
#    define _GLIBCXX_STDIO_EOF                          -1

/* Define to the value of the SEEK_CUR integer constant. */
#    define _GLIBCXX_STDIO_SEEK_CUR                     1

/* Define to the value of the SEEK_END integer constant. */
#    define _GLIBCXX_STDIO_SEEK_END                     2

/* Define to use symbol versioning in the shared library. */
#    define _GLIBCXX_SYMVER                             1

/* Define to use darwin versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_DARWIN */

/* Define to use GNU versioning in the shared library. */
#    define _GLIBCXX_SYMVER_GNU                         1

/* Define to use GNU namespace versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_GNU_NAMESPACE */

/* Define to use Sun versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_SUN */

/* Define if C11 functions in <uchar.h> should be imported into namespace std
   in <cuchar>. */
#    define _GLIBCXX_USE_C11_UCHAR_CXX11                1

/* Define if C99 functions or macros from <wchar.h>, <math.h>, <complex.h>,
   <stdio.h>, and <stdlib.h> can be used or exposed. */
#    define _GLIBCXX_USE_C99                            1

/* Define if C99 functions in <complex.h> should be used in <tr1/complex>.
   Using compiler builtins for these functions requires corresponding C99
   library functions to be present. */
#    define _GLIBCXX_USE_C99_COMPLEX_TR1                1

/* Define if C99 functions in <ctype.h> should be imported in <tr1/cctype> in
   namespace std::tr1. */
#    define _GLIBCXX_USE_C99_CTYPE_TR1                  1

/* Define if C99 functions in <fenv.h> should be imported in <tr1/cfenv> in
   namespace std::tr1. */
#    define _GLIBCXX_USE_C99_FENV_TR1                   1

/* Define if C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. */
#    define _GLIBCXX_USE_C99_INTTYPES_TR1               1

/* Define if wchar_t C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. */
#    define _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1       1

/* Define if C99 functions or macros in <math.h> should be imported in
   <tr1/cmath> in namespace std::tr1. */
#    define _GLIBCXX_USE_C99_MATH_TR1                   1

/* Define if C99 types in <stdint.h> should be imported in <tr1/cstdint> in
   namespace std::tr1. */
#    define _GLIBCXX_USE_C99_STDINT_TR1                 1

/* Define if usable chdir is available in <unistd.h>. */
#    define _GLIBCXX_USE_CHDIR                          1

/* Define if usable chmod is available in <sys/stat.h>. */
#    define _GLIBCXX_USE_CHMOD                          1

/* Defined if clock_gettime syscall has monotonic and realtime clock support.
   */
/* #undef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL */

/* Defined if clock_gettime has monotonic clock support. */
#    define _GLIBCXX_USE_CLOCK_MONOTONIC                1

/* Defined if clock_gettime has realtime clock support. */
#    define _GLIBCXX_USE_CLOCK_REALTIME                 1

/* Define if ISO/IEC TR 24733 decimal floating point types are supported on
   this host. */
#    define _GLIBCXX_USE_DECIMAL_FLOAT                  1

/* Define if /dev/random and /dev/urandom are available for
   std::random_device. */
#    define _GLIBCXX_USE_DEV_RANDOM                     1

/* Define if fchmod is available in <sys/stat.h>. */
#    define _GLIBCXX_USE_FCHMOD                         1

/* Define if fchmodat is available in <sys/stat.h>. */
#    define _GLIBCXX_USE_FCHMODAT                       1

/* Define if fseeko and ftello are available. */
#    define _GLIBCXX_USE_FSEEKO_FTELLO                  1

/* Define if usable getcwd is available in <unistd.h>. */
#    define _GLIBCXX_USE_GETCWD                         1

/* Defined if gettimeofday is available. */
#    define _GLIBCXX_USE_GETTIMEOFDAY                   1

/* Define if get_nprocs is available in <sys/sysinfo.h>. */
#    define _GLIBCXX_USE_GET_NPROCS                     1

/* Define if init_priority should be used for iostream initialization. */
#    define _GLIBCXX_USE_INIT_PRIORITY_ATTRIBUTE        1

/* Define if LFS support is available. */
#    define _GLIBCXX_USE_LFS                            1

/* Define if code specialized for long long should be used. */
#    define _GLIBCXX_USE_LONG_LONG                      1

/* Define if lstat is available in <sys/stat.h>. */
#    define _GLIBCXX_USE_LSTAT                          1

/* Define if usable mkdir is available in <sys/stat.h>. */
#    define _GLIBCXX_USE_MKDIR                          1

/* Defined if nanosleep is available. */
#    define _GLIBCXX_USE_NANOSLEEP                      1

/* Define if NLS translations are to be used. */
#    define _GLIBCXX_USE_NLS                            1

/* Define if pthreads_num_processors_np is available in <pthread.h>. */
/* #undef _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP */

/* Define if pthread_cond_clockwait is available in <pthread.h>. */
#    define _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT         1

/* Define if pthread_mutex_clocklock is available in <pthread.h>. */
#    define _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK        1

/* Define if pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock are
   available in <pthread.h>. */
#    define _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK       1

/* Define if POSIX read/write locks are available in <gthr.h>. */
#    define _GLIBCXX_USE_PTHREAD_RWLOCK_T               1

/* Define if /dev/random and /dev/urandom are available for the random_device
   of TR1 (Chapter 5.1). */
#    define _GLIBCXX_USE_RANDOM_TR1                     1

/* Define if usable realpath is available in <stdlib.h>. */
#    define _GLIBCXX_USE_REALPATH                       1

/* Defined if sched_yield is available. */
#    define _GLIBCXX_USE_SCHED_YIELD                    1

/* Define if _SC_NPROCESSORS_ONLN is available in <unistd.h>. */
#    define _GLIBCXX_USE_SC_NPROCESSORS_ONLN            1

/* Define if _SC_NPROC_ONLN is available in <unistd.h>. */
/* #undef _GLIBCXX_USE_SC_NPROC_ONLN */

/* Define if sendfile is available in <sys/sendfile.h>. */
#    define _GLIBCXX_USE_SENDFILE                       1

/* Define to restrict std::__basic_file<> to stdio APIs. */
/* #undef _GLIBCXX_USE_STDIO_PURE */

/* Define if struct stat has timespec members. */
#    define _GLIBCXX_USE_ST_MTIM                        1

/* Define if sysctl(), CTL_HW and HW_NCPU are available in <sys/sysctl.h>. */
/* #undef _GLIBCXX_USE_SYSCTL_HW_NCPU */

/* Define if obsolescent tmpnam is available in <stdio.h>. */
#    define _GLIBCXX_USE_TMPNAM                         1

/* Define if c8rtomb and mbrtoc8 functions in <uchar.h> should be imported
   into namespace std in <cuchar> for C++20. */
#    define _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_CXX20    1

/* Define if c8rtomb and mbrtoc8 functions in <uchar.h> should be imported
   into namespace std in <cuchar> for -fchar8_t. */
#    define _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_FCHAR8_T 1

/* Define if utime is available in <utime.h>. */
#    define _GLIBCXX_USE_UTIME                          1

/* Define if utimensat and UTIME_OMIT are available in <sys/stat.h> and
   AT_FDCWD in <fcntl.h>. */
#    define _GLIBCXX_USE_UTIMENSAT                      1

/* Define if code specialized for wchar_t should be used. */
#    define _GLIBCXX_USE_WCHAR_T                        1

/* Defined if Sleep exists. */
/* #undef _GLIBCXX_USE_WIN32_SLEEP */

/* Define to 1 if a verbose library is built, or 0 otherwise. */
#    define _GLIBCXX_VERBOSE                            1

/* Defined if as can handle rdrand. */
#    define _GLIBCXX_X86_RDRAND                         1

/* Defined if as can handle rdseed. */
#    define _GLIBCXX_X86_RDSEED                         1

/* Define if a directory should be searched for tzdata files. */
#    define _GLIBCXX_ZONEINFO_DIR                       "/usr/share/zoneinfo"

/* Define to 1 if mutex_timedlock is available. */
#    define _GTHREAD_USE_MUTEX_TIMEDLOCK                1

/* Define for large files, on AIX-style hosts. */
/* #undef _GLIBCXX_LARGE_FILES */

/* Define if all C++11 floating point overloads are available in <math.h>.  */
#    if __cplusplus >= 201103L
/* #undef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP */
#    endif

/* Define if all C++11 integral type overloads are available in <math.h>.  */
#    if __cplusplus >= 201103L
/* #undef __CORRECT_ISO_CPP11_MATH_H_PROTO_INT */
#    endif

#    if defined(_GLIBCXX_HAVE__ACOSF) && !defined(_GLIBCXX_HAVE_ACOSF)
#      define _GLIBCXX_HAVE_ACOSF 1
#      define acosf               _acosf
#    endif

#    if defined(_GLIBCXX_HAVE__ACOSL) && !defined(_GLIBCXX_HAVE_ACOSL)
#      define _GLIBCXX_HAVE_ACOSL 1
#      define acosl               _acosl
#    endif

#    if defined(_GLIBCXX_HAVE__ASINF) && !defined(_GLIBCXX_HAVE_ASINF)
#      define _GLIBCXX_HAVE_ASINF 1
#      define asinf               _asinf
#    endif

#    if defined(_GLIBCXX_HAVE__ASINL) && !defined(_GLIBCXX_HAVE_ASINL)
#      define _GLIBCXX_HAVE_ASINL 1
#      define asinl               _asinl
#    endif

#    if defined(_GLIBCXX_HAVE__ATAN2F) && !defined(_GLIBCXX_HAVE_ATAN2F)
#      define _GLIBCXX_HAVE_ATAN2F 1
#      define atan2f               _atan2f
#    endif

#    if defined(_GLIBCXX_HAVE__ATAN2L) && !defined(_GLIBCXX_HAVE_ATAN2L)
#      define _GLIBCXX_HAVE_ATAN2L 1
#      define atan2l               _atan2l
#    endif

#    if defined(_GLIBCXX_HAVE__ATANF) && !defined(_GLIBCXX_HAVE_ATANF)
#      define _GLIBCXX_HAVE_ATANF 1
#      define atanf               _atanf
#    endif

#    if defined(_GLIBCXX_HAVE__ATANL) && !defined(_GLIBCXX_HAVE_ATANL)
#      define _GLIBCXX_HAVE_ATANL 1
#      define atanl               _atanl
#    endif

#    if defined(_GLIBCXX_HAVE__CEILF) && !defined(_GLIBCXX_HAVE_CEILF)
#      define _GLIBCXX_HAVE_CEILF 1
#      define ceilf               _ceilf
#    endif

#    if defined(_GLIBCXX_HAVE__CEILL) && !defined(_GLIBCXX_HAVE_CEILL)
#      define _GLIBCXX_HAVE_CEILL 1
#      define ceill               _ceill
#    endif

#    if defined(_GLIBCXX_HAVE__COSF) && !defined(_GLIBCXX_HAVE_COSF)
#      define _GLIBCXX_HAVE_COSF 1
#      define cosf               _cosf
#    endif

#    if defined(_GLIBCXX_HAVE__COSHF) && !defined(_GLIBCXX_HAVE_COSHF)
#      define _GLIBCXX_HAVE_COSHF 1
#      define coshf               _coshf
#    endif

#    if defined(_GLIBCXX_HAVE__COSHL) && !defined(_GLIBCXX_HAVE_COSHL)
#      define _GLIBCXX_HAVE_COSHL 1
#      define coshl               _coshl
#    endif

#    if defined(_GLIBCXX_HAVE__COSL) && !defined(_GLIBCXX_HAVE_COSL)
#      define _GLIBCXX_HAVE_COSL 1
#      define cosl               _cosl
#    endif

#    if defined(_GLIBCXX_HAVE__EXPF) && !defined(_GLIBCXX_HAVE_EXPF)
#      define _GLIBCXX_HAVE_EXPF 1
#      define expf               _expf
#    endif

#    if defined(_GLIBCXX_HAVE__EXPL) && !defined(_GLIBCXX_HAVE_EXPL)
#      define _GLIBCXX_HAVE_EXPL 1
#      define expl               _expl
#    endif

#    if defined(_GLIBCXX_HAVE__FABSF) && !defined(_GLIBCXX_HAVE_FABSF)
#      define _GLIBCXX_HAVE_FABSF 1
#      define fabsf               _fabsf
#    endif

#    if defined(_GLIBCXX_HAVE__FABSL) && !defined(_GLIBCXX_HAVE_FABSL)
#      define _GLIBCXX_HAVE_FABSL 1
#      define fabsl               _fabsl
#    endif

#    if defined(_GLIBCXX_HAVE__FINITE) && !defined(_GLIBCXX_HAVE_FINITE)
#      define _GLIBCXX_HAVE_FINITE 1
#      define finite               _finite
#    endif

#    if defined(_GLIBCXX_HAVE__FINITEF) && !defined(_GLIBCXX_HAVE_FINITEF)
#      define _GLIBCXX_HAVE_FINITEF 1
#      define finitef               _finitef
#    endif

#    if defined(_GLIBCXX_HAVE__FINITEL) && !defined(_GLIBCXX_HAVE_FINITEL)
#      define _GLIBCXX_HAVE_FINITEL 1
#      define finitel               _finitel
#    endif

#    if defined(_GLIBCXX_HAVE__FLOORF) && !defined(_GLIBCXX_HAVE_FLOORF)
#      define _GLIBCXX_HAVE_FLOORF 1
#      define floorf               _floorf
#    endif

#    if defined(_GLIBCXX_HAVE__FLOORL) && !defined(_GLIBCXX_HAVE_FLOORL)
#      define _GLIBCXX_HAVE_FLOORL 1
#      define floorl               _floorl
#    endif

#    if defined(_GLIBCXX_HAVE__FMODF) && !defined(_GLIBCXX_HAVE_FMODF)
#      define _GLIBCXX_HAVE_FMODF 1
#      define fmodf               _fmodf
#    endif

#    if defined(_GLIBCXX_HAVE__FMODL) && !defined(_GLIBCXX_HAVE_FMODL)
#      define _GLIBCXX_HAVE_FMODL 1
#      define fmodl               _fmodl
#    endif

#    if defined(_GLIBCXX_HAVE__FPCLASS) && !defined(_GLIBCXX_HAVE_FPCLASS)
#      define _GLIBCXX_HAVE_FPCLASS 1
#      define fpclass               _fpclass
#    endif

#    if defined(_GLIBCXX_HAVE__FREXPF) && !defined(_GLIBCXX_HAVE_FREXPF)
#      define _GLIBCXX_HAVE_FREXPF 1
#      define frexpf               _frexpf
#    endif

#    if defined(_GLIBCXX_HAVE__FREXPL) && !defined(_GLIBCXX_HAVE_FREXPL)
#      define _GLIBCXX_HAVE_FREXPL 1
#      define frexpl               _frexpl
#    endif

#    if defined(_GLIBCXX_HAVE__HYPOT) && !defined(_GLIBCXX_HAVE_HYPOT)
#      define _GLIBCXX_HAVE_HYPOT 1
#      define hypot               _hypot
#    endif

#    if defined(_GLIBCXX_HAVE__HYPOTF) && !defined(_GLIBCXX_HAVE_HYPOTF)
#      define _GLIBCXX_HAVE_HYPOTF 1
#      define hypotf               _hypotf
#    endif

#    if defined(_GLIBCXX_HAVE__HYPOTL) && !defined(_GLIBCXX_HAVE_HYPOTL)
#      define _GLIBCXX_HAVE_HYPOTL 1
#      define hypotl               _hypotl
#    endif

#    if defined(_GLIBCXX_HAVE__ISINF) && !defined(_GLIBCXX_HAVE_ISINF)
#      define _GLIBCXX_HAVE_ISINF 1
#      define isinf               _isinf
#    endif

#    if defined(_GLIBCXX_HAVE__ISINFF) && !defined(_GLIBCXX_HAVE_ISINFF)
#      define _GLIBCXX_HAVE_ISINFF 1
#      define isinff               _isinff
#    endif

#    if defined(_GLIBCXX_HAVE__ISINFL) && !defined(_GLIBCXX_HAVE_ISINFL)
#      define _GLIBCXX_HAVE_ISINFL 1
#      define isinfl               _isinfl
#    endif

#    if defined(_GLIBCXX_HAVE__ISNAN) && !defined(_GLIBCXX_HAVE_ISNAN)
#      define _GLIBCXX_HAVE_ISNAN 1
#      define isnan               _isnan
#    endif

#    if defined(_GLIBCXX_HAVE__ISNANF) && !defined(_GLIBCXX_HAVE_ISNANF)
#      define _GLIBCXX_HAVE_ISNANF 1
#      define isnanf               _isnanf
#    endif

#    if defined(_GLIBCXX_HAVE__ISNANL) && !defined(_GLIBCXX_HAVE_ISNANL)
#      define _GLIBCXX_HAVE_ISNANL 1
#      define isnanl               _isnanl
#    endif

#    if defined(_GLIBCXX_HAVE__LDEXPF) && !defined(_GLIBCXX_HAVE_LDEXPF)
#      define _GLIBCXX_HAVE_LDEXPF 1
#      define ldexpf               _ldexpf
#    endif

#    if defined(_GLIBCXX_HAVE__LDEXPL) && !defined(_GLIBCXX_HAVE_LDEXPL)
#      define _GLIBCXX_HAVE_LDEXPL 1
#      define ldexpl               _ldexpl
#    endif

#    if defined(_GLIBCXX_HAVE__LOG10F) && !defined(_GLIBCXX_HAVE_LOG10F)
#      define _GLIBCXX_HAVE_LOG10F 1
#      define log10f               _log10f
#    endif

#    if defined(_GLIBCXX_HAVE__LOG10L) && !defined(_GLIBCXX_HAVE_LOG10L)
#      define _GLIBCXX_HAVE_LOG10L 1
#      define log10l               _log10l
#    endif

#    if defined(_GLIBCXX_HAVE__LOGF) && !defined(_GLIBCXX_HAVE_LOGF)
#      define _GLIBCXX_HAVE_LOGF 1
#      define logf               _logf
#    endif

#    if defined(_GLIBCXX_HAVE__LOGL) && !defined(_GLIBCXX_HAVE_LOGL)
#      define _GLIBCXX_HAVE_LOGL 1
#      define logl               _logl
#    endif

#    if defined(_GLIBCXX_HAVE__MODF) && !defined(_GLIBCXX_HAVE_MODF)
#      define _GLIBCXX_HAVE_MODF 1
#      define modf               _modf
#    endif

#    if defined(_GLIBCXX_HAVE__MODFF) && !defined(_GLIBCXX_HAVE_MODFF)
#      define _GLIBCXX_HAVE_MODFF 1
#      define modff               _modff
#    endif

#    if defined(_GLIBCXX_HAVE__MODFL) && !defined(_GLIBCXX_HAVE_MODFL)
#      define _GLIBCXX_HAVE_MODFL 1
#      define modfl               _modfl
#    endif

#    if defined(_GLIBCXX_HAVE__POWF) && !defined(_GLIBCXX_HAVE_POWF)
#      define _GLIBCXX_HAVE_POWF 1
#      define powf               _powf
#    endif

#    if defined(_GLIBCXX_HAVE__POWL) && !defined(_GLIBCXX_HAVE_POWL)
#      define _GLIBCXX_HAVE_POWL 1
#      define powl               _powl
#    endif

#    if defined(_GLIBCXX_HAVE__QFPCLASS) && !defined(_GLIBCXX_HAVE_QFPCLASS)
#      define _GLIBCXX_HAVE_QFPCLASS 1
#      define qfpclass               _qfpclass
#    endif

#    if defined(_GLIBCXX_HAVE__SINCOS) && !defined(_GLIBCXX_HAVE_SINCOS)
#      define _GLIBCXX_HAVE_SINCOS 1
#      define sincos               _sincos
#    endif

#    if defined(_GLIBCXX_HAVE__SINCOSF) && !defined(_GLIBCXX_HAVE_SINCOSF)
#      define _GLIBCXX_HAVE_SINCOSF 1
#      define sincosf               _sincosf
#    endif

#    if defined(_GLIBCXX_HAVE__SINCOSL) && !defined(_GLIBCXX_HAVE_SINCOSL)
#      define _GLIBCXX_HAVE_SINCOSL 1
#      define sincosl               _sincosl
#    endif

#    if defined(_GLIBCXX_HAVE__SINF) && !defined(_GLIBCXX_HAVE_SINF)
#      define _GLIBCXX_HAVE_SINF 1
#      define sinf               _sinf
#    endif

#    if defined(_GLIBCXX_HAVE__SINHF) && !defined(_GLIBCXX_HAVE_SINHF)
#      define _GLIBCXX_HAVE_SINHF 1
#      define sinhf               _sinhf
#    endif

#    if defined(_GLIBCXX_HAVE__SINHL) && !defined(_GLIBCXX_HAVE_SINHL)
#      define _GLIBCXX_HAVE_SINHL 1
#      define sinhl               _sinhl
#    endif

#    if defined(_GLIBCXX_HAVE__SINL) && !defined(_GLIBCXX_HAVE_SINL)
#      define _GLIBCXX_HAVE_SINL 1
#      define sinl               _sinl
#    endif

#    if defined(_GLIBCXX_HAVE__SQRTF) && !defined(_GLIBCXX_HAVE_SQRTF)
#      define _GLIBCXX_HAVE_SQRTF 1
#      define sqrtf               _sqrtf
#    endif

#    if defined(_GLIBCXX_HAVE__SQRTL) && !defined(_GLIBCXX_HAVE_SQRTL)
#      define _GLIBCXX_HAVE_SQRTL 1
#      define sqrtl               _sqrtl
#    endif

#    if defined(_GLIBCXX_HAVE__STRTOF) && !defined(_GLIBCXX_HAVE_STRTOF)
#      define _GLIBCXX_HAVE_STRTOF 1
#      define strtof               _strtof
#    endif

#    if defined(_GLIBCXX_HAVE__STRTOLD) && !defined(_GLIBCXX_HAVE_STRTOLD)
#      define _GLIBCXX_HAVE_STRTOLD 1
#      define strtold               _strtold
#    endif

#    if defined(_GLIBCXX_HAVE__TANF) && !defined(_GLIBCXX_HAVE_TANF)
#      define _GLIBCXX_HAVE_TANF 1
#      define tanf               _tanf
#    endif

#    if defined(_GLIBCXX_HAVE__TANHF) && !defined(_GLIBCXX_HAVE_TANHF)
#      define _GLIBCXX_HAVE_TANHF 1
#      define tanhf               _tanhf
#    endif

#    if defined(_GLIBCXX_HAVE__TANHL) && !defined(_GLIBCXX_HAVE_TANHL)
#      define _GLIBCXX_HAVE_TANHL 1
#      define tanhl               _tanhl
#    endif

#    if defined(_GLIBCXX_HAVE__TANL) && !defined(_GLIBCXX_HAVE_TANL)
#      define _GLIBCXX_HAVE_TANL 1
#      define tanl               _tanl
#    endif

#  endif // _GLIBCXX_CXX_CONFIG_H

namespace std _GLIBCXX_VISIBILITY(default) {
_GLIBCXX_BEGIN_NAMESPACE_VERSION

template <typename _Tp>
class reference_wrapper;

/**
   * @defgroup metaprogramming Metaprogramming
   * @ingroup utilities
   *
   * Template utilities for compile-time introspection and modification,
   * including type classification traits, type property inspection traits
   * and type transformation traits.
   *
   * @since C++11
   *
   * @{
   */

/// integral_constant
template <typename _Tp, _Tp __v>
struct integral_constant {
  static constexpr _Tp                value = __v;
  typedef _Tp                         value_type;
  typedef integral_constant<_Tp, __v> type;
  constexpr operator value_type() const noexcept {
    return value;
  }
#  if __cplusplus > 201103L

#    define __cpp_lib_integral_constant_callable 201304L

  constexpr value_type operator()() const noexcept {
    return value;
  }
#  endif
};

#  if !__cpp_inline_variables
template <typename _Tp, _Tp __v>
constexpr _Tp integral_constant<_Tp, __v>::value;
#  endif

/// The type used as a compile-time boolean with true value.
using true_type = integral_constant<bool, true>;

/// The type used as a compile-time boolean with false value.
using false_type = integral_constant<bool, false>;

/// @cond undocumented
/// bool_constant for C++11
template <bool __v>
using __bool_constant = integral_constant<bool, __v>;
/// @endcond

#  if __cplusplus >= 201703L
#    define __cpp_lib_bool_constant 201505L
/// Alias template for compile-time boolean constant types.
/// @since C++17
template <bool __v>
using bool_constant = integral_constant<bool, __v>;
#  endif

// Metaprogramming helper types.

// Primary template.
/// Define a member typedef `type` only if a boolean constant is true.
template <bool, typename _Tp = void>
struct enable_if {};

// Partial specialization for true.
template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

// __enable_if_t (std::enable_if_t for C++11)
template <bool _Cond, typename _Tp = void>
using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

template <bool>
struct __conditional {
  template <typename _Tp, typename>
  using type = _Tp;
};

template <>
struct __conditional<false> {
  template <typename, typename _Up>
  using type = _Up;
};

// More efficient version of std::conditional_t for internal use (and C++11)
template <bool _Cond, typename _If, typename _Else>
using __conditional_t = typename __conditional<_Cond>::template type<_If, _Else>;

/// @cond undocumented
template <typename _Type>
struct __type_identity {
  using type = _Type;
};

template <typename _Tp>
using __type_identity_t = typename __type_identity<_Tp>::type;

namespace __detail {
// A variadic alias template that resolves to its first argument.
template <typename _Tp, typename...>
using __first_t = _Tp;

// These are deliberately not defined.
template <typename... _Bn>
auto __or_fn(int) -> __first_t<false_type, __enable_if_t<!bool(_Bn::value)>...>;

template <typename... _Bn>
auto __or_fn(...) -> true_type;

template <typename... _Bn>
auto __and_fn(int) -> __first_t<true_type, __enable_if_t<bool(_Bn::value)>...>;

template <typename... _Bn>
auto __and_fn(...) -> false_type;
} // namespace __detail

// Like C++17 std::dis/conjunction, but usable in C++11 and resolves
// to either true_type or false_type which allows for a more efficient
// implementation that avoids recursive class template instantiation.
template <typename... _Bn>
struct __or_ : decltype(__detail::__or_fn<_Bn...>(0)) {};

template <typename... _Bn>
struct __and_ : decltype(__detail::__and_fn<_Bn...>(0)) {};

template <typename _Pp>
struct __not_ : __bool_constant<!bool(_Pp::value)> {};
/// @endcond

#  if __cplusplus >= 201703L

/// @cond undocumented
template <typename... _Bn>
inline constexpr bool __or_v = __or_<_Bn...>::value;
template <typename... _Bn>
inline constexpr bool __and_v = __and_<_Bn...>::value;

namespace __detail {
template <typename /* = void */, typename _B1, typename... _Bn>
struct __disjunction_impl {
  using type = _B1;
};

template <typename _B1, typename _B2, typename... _Bn>
struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...> {
  using type = typename __disjunction_impl<void, _B2, _Bn...>::type;
};

template <typename /* = void */, typename _B1, typename... _Bn>
struct __conjunction_impl {
  using type = _B1;
};

template <typename _B1, typename _B2, typename... _Bn>
struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...> {
  using type = typename __conjunction_impl<void, _B2, _Bn...>::type;
};
} // namespace __detail
/// @endcond

#    define __cpp_lib_logical_traits 201510L

template <typename... _Bn>
struct conjunction : __detail::__conjunction_impl<void, _Bn...>::type {};

template <>
struct conjunction<> : true_type {};

template <typename... _Bn>
struct disjunction : __detail::__disjunction_impl<void, _Bn...>::type {};

template <>
struct disjunction<> : false_type {};

template <typename _Pp>
struct negation : __not_<_Pp>::type {};

/** @ingroup variable_templates
   * @{
   */
template <typename... _Bn>
inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

template <typename... _Bn>
inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

template <typename _Pp>
inline constexpr bool negation_v = negation<_Pp>::value;
/// @}

#  endif // C++17

// Forward declarations
template <typename>
struct is_reference;
template <typename>
struct is_function;
template <typename>
struct is_void;
template <typename>
struct remove_cv;
template <typename>
struct is_const;

/// @cond undocumented
template <typename>
struct __is_array_unknown_bounds;

// Helper functions that return false_type for incomplete classes,
// incomplete unions and arrays of known bound from those.

template <typename _Tp, size_t = sizeof(_Tp)>
constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>) {
  return {};
}

template <typename _TypeIdentity, typename _NestedType = typename _TypeIdentity::type>
constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>, is_void<_NestedType>,
                         __is_array_unknown_bounds<_NestedType>>::type
__is_complete_or_unbounded(_TypeIdentity) {
  return {};
}

// __remove_cv_t (std::remove_cv_t for C++11).
template <typename _Tp>
using __remove_cv_t = typename remove_cv<_Tp>::type;
/// @endcond

// Primary type categories.

/// is_void
template <typename _Tp>
struct is_void : public false_type {};

template <>
struct is_void<void> : public true_type {};

template <>
struct is_void<const void> : public true_type {};

template <>
struct is_void<volatile void> : public true_type {};

template <>
struct is_void<const volatile void> : public true_type {};

/// @cond undocumented
template <typename>
struct __is_integral_helper : public false_type {};

template <>
struct __is_integral_helper<bool> : public true_type {};

template <>
struct __is_integral_helper<char> : public true_type {};

template <>
struct __is_integral_helper<signed char> : public true_type {};

template <>
struct __is_integral_helper<unsigned char> : public true_type {};

// We want is_integral<wchar_t> to be true (and make_signed/unsigned to work)
// even when libc doesn't provide working <wchar.h> and related functions,
// so don't check _GLIBCXX_USE_WCHAR_T here.
template <>
struct __is_integral_helper<wchar_t> : public true_type {};

#  ifdef _GLIBCXX_USE_CHAR8_T
template <>
struct __is_integral_helper<char8_t> : public true_type {};
#  endif

template <>
struct __is_integral_helper<char16_t> : public true_type {};

template <>
struct __is_integral_helper<char32_t> : public true_type {};

template <>
struct __is_integral_helper<short> : public true_type {};

template <>
struct __is_integral_helper<unsigned short> : public true_type {};

template <>
struct __is_integral_helper<int> : public true_type {};

template <>
struct __is_integral_helper<unsigned int> : public true_type {};

template <>
struct __is_integral_helper<long> : public true_type {};

template <>
struct __is_integral_helper<unsigned long> : public true_type {};

template <>
struct __is_integral_helper<long long> : public true_type {};

template <>
struct __is_integral_helper<unsigned long long> : public true_type {};

// Conditionalizing on __STRICT_ANSI__ here will break any port that
// uses one of these types for size_t.
#  if defined(__GLIBCXX_TYPE_INT_N_0)
__extension__ template <>
struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_0> : public true_type {};

__extension__ template <>
struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_0> : public true_type {};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_1)
__extension__ template <>
struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_1> : public true_type {};

__extension__ template <>
struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_1> : public true_type {};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_2)
__extension__ template <>
struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_2> : public true_type {};

__extension__ template <>
struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_2> : public true_type {};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_3)
__extension__ template <>
struct __is_integral_helper<__GLIBCXX_TYPE_INT_N_3> : public true_type {};

__extension__ template <>
struct __is_integral_helper<unsigned __GLIBCXX_TYPE_INT_N_3> : public true_type {};
#  endif
/// @endcond

/// is_integral
template <typename _Tp>
struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {};

/// @cond undocumented
template <typename>
struct __is_floating_point_helper : public false_type {};

template <>
struct __is_floating_point_helper<float> : public true_type {};

template <>
struct __is_floating_point_helper<double> : public true_type {};

template <>
struct __is_floating_point_helper<long double> : public true_type {};

#  ifdef __STDCPP_FLOAT16_T__
template <>
struct __is_floating_point_helper<_Float16> : public true_type {};
#  endif

#  ifdef __STDCPP_FLOAT32_T__
template <>
struct __is_floating_point_helper<_Float32> : public true_type {};
#  endif

#  ifdef __STDCPP_FLOAT64_T__
template <>
struct __is_floating_point_helper<_Float64> : public true_type {};
#  endif

#  ifdef __STDCPP_FLOAT128_T__
template <>
struct __is_floating_point_helper<_Float128> : public true_type {};
#  endif

#  ifdef __STDCPP_BFLOAT16_T__
template <>
struct __is_floating_point_helper<__gnu_cxx::__bfloat16_t> : public true_type {};
#  endif

#  if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128) && !defined(__CUDACC__)
template <>
struct __is_floating_point_helper<__float128> : public true_type {};
#  endif
/// @endcond

/// is_floating_point
template <typename _Tp>
struct is_floating_point : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {};

/// is_array
template <typename>
struct is_array : public false_type {};

template <typename _Tp, std::size_t _Size>
struct is_array<_Tp[_Size]> : public true_type {};

template <typename _Tp>
struct is_array<_Tp[]> : public true_type {};

template <typename>
struct __is_pointer_helper : public false_type {};

template <typename _Tp>
struct __is_pointer_helper<_Tp *> : public true_type {};

/// is_pointer
template <typename _Tp>
struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {};

/// is_lvalue_reference
template <typename>
struct is_lvalue_reference : public false_type {};

template <typename _Tp>
struct is_lvalue_reference<_Tp &> : public true_type {};

/// is_rvalue_reference
template <typename>
struct is_rvalue_reference : public false_type {};

template <typename _Tp>
struct is_rvalue_reference<_Tp &&> : public true_type {};

template <typename>
struct __is_member_object_pointer_helper : public false_type {};

template <typename _Tp, typename _Cp>
struct __is_member_object_pointer_helper<_Tp _Cp::*> : public __not_<is_function<_Tp>>::type {};

/// is_member_object_pointer
template <typename _Tp>
struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {};

template <typename>
struct __is_member_function_pointer_helper : public false_type {};

template <typename _Tp, typename _Cp>
struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type {};

/// is_member_function_pointer
template <typename _Tp>
struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {};

/// is_enum
template <typename _Tp>
struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};

/// is_union
template <typename _Tp>
struct is_union : public integral_constant<bool, __is_union(_Tp)> {};

/// is_class
template <typename _Tp>
struct is_class : public integral_constant<bool, __is_class(_Tp)> {};

/// is_function
template <typename _Tp>
struct is_function : public __bool_constant<!is_const<const _Tp>::value> {};

template <typename _Tp>
struct is_function<_Tp &> : public false_type {};

template <typename _Tp>
struct is_function<_Tp &&> : public false_type {};

#  define __cpp_lib_is_null_pointer 201309L

/// is_null_pointer (LWG 2247).
template <typename _Tp>
struct is_null_pointer : public false_type {};

template <>
struct is_null_pointer<std::nullptr_t> : public true_type {};

template <>
struct is_null_pointer<const std::nullptr_t> : public true_type {};

template <>
struct is_null_pointer<volatile std::nullptr_t> : public true_type {};

template <>
struct is_null_pointer<const volatile std::nullptr_t> : public true_type {};

/// __is_nullptr_t (deprecated extension).
/// @deprecated Non-standard. Use `is_null_pointer` instead.
template <typename _Tp>
struct __is_nullptr_t : public is_null_pointer<_Tp> {
} _GLIBCXX_DEPRECATED_SUGGEST("std::is_null_pointer");

// Composite type categories.

/// is_reference
template <typename _Tp>
struct is_reference : public false_type {};

template <typename _Tp>
struct is_reference<_Tp &> : public true_type {};

template <typename _Tp>
struct is_reference<_Tp &&> : public true_type {};

/// is_arithmetic
template <typename _Tp>
struct is_arithmetic : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {};

/// is_fundamental
template <typename _Tp>
struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, is_null_pointer<_Tp>>::type {
};

/// is_object
template <typename _Tp>
struct is_object : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {};

template <typename>
struct is_member_pointer;

/// is_scalar
template <typename _Tp>
struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                                is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {};

/// is_compound
template <typename _Tp>
struct is_compound : public __not_<is_fundamental<_Tp>>::type {};

/// @cond undocumented
template <typename _Tp>
struct __is_member_pointer_helper : public false_type {};

template <typename _Tp, typename _Cp>
struct __is_member_pointer_helper<_Tp _Cp::*> : public true_type {};
/// @endcond

/// is_member_pointer
template <typename _Tp>
struct is_member_pointer : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {};

template <typename, typename>
struct is_same;

/// @cond undocumented
template <typename _Tp, typename... _Types>
using __is_one_of = __or_<is_same<_Tp, _Types>...>;

// Check if a type is one of the signed integer types.
__extension__ template <typename _Tp>
using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>, signed char, signed short, signed int,
                                        signed long, signed long long
#  if defined(__GLIBCXX_TYPE_INT_N_0)
                                        ,
                                        signed __GLIBCXX_TYPE_INT_N_0
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_1)
                                        ,
                                        signed __GLIBCXX_TYPE_INT_N_1
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_2)
                                        ,
                                        signed __GLIBCXX_TYPE_INT_N_2
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_3)
                                        ,
                                        signed __GLIBCXX_TYPE_INT_N_3
#  endif
                                        >;

// Check if a type is one of the unsigned integer types.
__extension__ template <typename _Tp>
using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short,
                                          unsigned int, unsigned long, unsigned long long
#  if defined(__GLIBCXX_TYPE_INT_N_0)
                                          ,
                                          unsigned __GLIBCXX_TYPE_INT_N_0
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_1)
                                          ,
                                          unsigned __GLIBCXX_TYPE_INT_N_1
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_2)
                                          ,
                                          unsigned __GLIBCXX_TYPE_INT_N_2
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_3)
                                          ,
                                          unsigned __GLIBCXX_TYPE_INT_N_3
#  endif
                                          >;

// Check if a type is one of the signed or unsigned integer types.
template <typename _Tp>
using __is_standard_integer = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;

// __void_t (std::void_t for C++11)
template <typename...>
using __void_t = void;
/// @endcond

// Type properties.

/// is_const
template <typename>
struct is_const : public false_type {};

template <typename _Tp>
struct is_const<_Tp const> : public true_type {};

/// is_volatile
template <typename>
struct is_volatile : public false_type {};

template <typename _Tp>
struct is_volatile<_Tp volatile> : public true_type {};

/// is_trivial
template <typename _Tp>
struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_trivially_copyable
template <typename _Tp>
struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_standard_layout
template <typename _Tp>
struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/** is_pod
   * @deprecated Deprecated in C++20.
   * Use `is_standard_layout && is_trivial` instead.
   */
// Could use is_standard_layout && is_trivial instead of the builtin.
template <typename _Tp>
struct _GLIBCXX20_DEPRECATED_SUGGEST("is_standard_layout && is_trivial") is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/** is_literal_type
   * @deprecated Deprecated in C++17, removed in C++20.
   * The idea of a literal type isn't useful.
   */
template <typename _Tp>
struct _GLIBCXX17_DEPRECATED is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_empty
template <typename _Tp>
struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {};

/// is_polymorphic
template <typename _Tp>
struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {};

#  if __cplusplus >= 201402L
#    define __cpp_lib_is_final 201402L
/// is_final
/// @since C++14
template <typename _Tp>
struct is_final : public integral_constant<bool, __is_final(_Tp)> {};
#  endif

/// is_abstract
template <typename _Tp>
struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {};

/// @cond undocumented
template <typename _Tp, bool = is_arithmetic<_Tp>::value>
struct __is_signed_helper : public false_type {};

template <typename _Tp>
struct __is_signed_helper<_Tp, true> : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};
/// @endcond

/// is_signed
template <typename _Tp>
struct is_signed : public __is_signed_helper<_Tp>::type {};

/// is_unsigned
template <typename _Tp>
struct is_unsigned : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type {};

/// @cond undocumented
template <typename _Tp, typename _Up = _Tp &&>
_Up __declval(int);

template <typename _Tp>
_Tp __declval(long);
/// @endcond

template <typename _Tp>
auto declval() noexcept -> decltype(__declval<_Tp>(0));

template <typename>
struct remove_all_extents;

/// @cond undocumented
template <typename _Tp>
struct __is_array_known_bounds : public false_type {};

template <typename _Tp, size_t _Size>
struct __is_array_known_bounds<_Tp[_Size]> : public true_type {};

template <typename _Tp>
struct __is_array_unknown_bounds : public false_type {};

template <typename _Tp>
struct __is_array_unknown_bounds<_Tp[]> : public true_type {};

// Destructible and constructible type properties.

// In N3290 is_destructible does not say anything about function
// types and abstract types, see LWG 2049. This implementation
// describes function types as non-destructible and all complete
// object types as destructible, iff the explicit destructor
// call expression is wellformed.
struct __do_is_destructible_impl {
  template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())>
  static true_type __test(int);

  template <typename>
  static false_type __test(...);
};

template <typename _Tp>
struct __is_destructible_impl : public __do_is_destructible_impl {
  typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp,
          bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value,
          bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
struct __is_destructible_safe;

template <typename _Tp>
struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type {};

template <typename _Tp>
struct __is_destructible_safe<_Tp, true, false> : public false_type {};

template <typename _Tp>
struct __is_destructible_safe<_Tp, false, true> : public true_type {};
/// @endcond

/// is_destructible
template <typename _Tp>
struct is_destructible : public __is_destructible_safe<_Tp>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented

// is_nothrow_destructible requires that is_destructible is
// satisfied as well.  We realize that by mimicing the
// implementation of is_destructible but refer to noexcept(expr)
// instead of decltype(expr).
struct __do_is_nt_destructible_impl {
  template <typename _Tp>
  static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);

  template <typename>
  static false_type __test(...);
};

template <typename _Tp>
struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl {
  typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp,
          bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp>>::value,
          bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
struct __is_nt_destructible_safe;

template <typename _Tp>
struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type {};

template <typename _Tp>
struct __is_nt_destructible_safe<_Tp, true, false> : public false_type {};

template <typename _Tp>
struct __is_nt_destructible_safe<_Tp, false, true> : public true_type {};
/// @endcond

/// is_nothrow_destructible
template <typename _Tp>
struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename... _Args>
using __is_constructible_impl = __bool_constant<__is_constructible(_Tp, _Args...)>;
/// @endcond

/// is_constructible
template <typename _Tp, typename... _Args>
struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_default_constructible
template <typename _Tp>
struct is_default_constructible : public __is_constructible_impl<_Tp> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename = void>
struct __add_lvalue_reference_helper {
  using type = _Tp;
};

template <typename _Tp>
struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp &>> {
  using type = _Tp &;
};

template <typename _Tp>
using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;
/// @endcond

/// is_copy_constructible
template <typename _Tp>
struct is_copy_constructible : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename = void>
struct __add_rvalue_reference_helper {
  using type = _Tp;
};

template <typename _Tp>
struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp &&>> {
  using type = _Tp &&;
};

template <typename _Tp>
using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;
/// @endcond

/// is_move_constructible
template <typename _Tp>
struct is_move_constructible : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename... _Args>
using __is_nothrow_constructible_impl = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;
/// @endcond

/// is_nothrow_constructible
template <typename _Tp, typename... _Args>
struct is_nothrow_constructible : public __is_nothrow_constructible_impl<_Tp, _Args...> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_nothrow_default_constructible
template <typename _Tp>
struct is_nothrow_default_constructible : public __is_nothrow_constructible_impl<_Tp> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_nothrow_copy_constructible
template <typename _Tp>
struct is_nothrow_copy_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_nothrow_move_constructible
template <typename _Tp>
struct is_nothrow_move_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename _Up>
using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;
/// @endcond

/// is_assignable
template <typename _Tp, typename _Up>
struct is_assignable : public __is_assignable_impl<_Tp, _Up> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_copy_assignable
template <typename _Tp>
struct is_copy_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_move_assignable
template <typename _Tp>
struct is_move_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename _Up>
using __is_nothrow_assignable_impl = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;
/// @endcond

/// is_nothrow_assignable
template <typename _Tp, typename _Up>
struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_nothrow_copy_assignable
template <typename _Tp>
struct is_nothrow_copy_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_nothrow_move_assignable
template <typename _Tp>
struct is_nothrow_move_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename... _Args>
using __is_trivially_constructible_impl =
    __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;
/// @endcond

/// is_trivially_constructible
template <typename _Tp, typename... _Args>
struct is_trivially_constructible : public __is_trivially_constructible_impl<_Tp, _Args...> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_trivially_default_constructible
template <typename _Tp>
struct is_trivially_default_constructible : public __is_trivially_constructible_impl<_Tp> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

struct __do_is_implicitly_default_constructible_impl {
  template <typename _Tp>
  static void __helper(const _Tp &);

  template <typename _Tp>
  static true_type __test(const _Tp &, decltype(__helper<const _Tp &>({})) * = 0);

  static false_type __test(...);
};

template <typename _Tp>
struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl {
  typedef decltype(__test(declval<_Tp>())) type;
};

template <typename _Tp>
struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type {};

template <typename _Tp>
struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
                    __is_implicitly_default_constructible_safe<_Tp>>::type {};

/// is_trivially_copy_constructible
template <typename _Tp>
struct is_trivially_copy_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_trivially_move_constructible
template <typename _Tp>
struct is_trivially_move_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @cond undocumented
template <typename _Tp, typename _Up>
using __is_trivially_assignable_impl = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;
/// @endcond

/// is_trivially_assignable
template <typename _Tp, typename _Up>
struct is_trivially_assignable : public __is_trivially_assignable_impl<_Tp, _Up> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_trivially_copy_assignable
template <typename _Tp>
struct is_trivially_copy_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_trivially_move_assignable
template <typename _Tp>
struct is_trivially_move_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_trivially_destructible
template <typename _Tp>
struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
                    __bool_constant<__has_trivial_destructor(_Tp)>>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// has_virtual_destructor
template <typename _Tp>
struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

// type property queries.

/// alignment_of
template <typename _Tp>
struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// rank
template <typename>
struct rank : public integral_constant<std::size_t, 0> {};

template <typename _Tp, std::size_t _Size>
struct rank<_Tp[_Size]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {};

template <typename _Tp>
struct rank<_Tp[]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {};

/// extent
template <typename, unsigned _Uint = 0>
struct extent : public integral_constant<size_t, 0> {};

template <typename _Tp, size_t _Size>
struct extent<_Tp[_Size], 0> : public integral_constant<size_t, _Size> {};

template <typename _Tp, unsigned _Uint, size_t _Size>
struct extent<_Tp[_Size], _Uint> : public extent<_Tp, _Uint - 1>::type {};

template <typename _Tp>
struct extent<_Tp[], 0> : public integral_constant<size_t, 0> {};

template <typename _Tp, unsigned _Uint>
struct extent<_Tp[], _Uint> : public extent<_Tp, _Uint - 1>::type {};

// Type relations.

/// is_same
template <typename _Tp, typename _Up>
struct is_same
#  ifdef _GLIBCXX_HAVE_BUILTIN_IS_SAME
    : public integral_constant<bool, __is_same(_Tp, _Up)>
#  else
    : public false_type
#  endif
{
};

#  ifndef _GLIBCXX_HAVE_BUILTIN_IS_SAME
template <typename _Tp>
struct is_same<_Tp, _Tp> : public true_type {};
#  endif

/// is_base_of
template <typename _Base, typename _Derived>
struct is_base_of : public integral_constant<bool, __is_base_of(_Base, _Derived)> {};

#  if __has_builtin(__is_convertible)
template <typename _From, typename _To>
struct is_convertible : public __bool_constant<__is_convertible(_From, _To)> {};
#  else
template <typename _From, typename _To,
          bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value>
struct __is_convertible_helper {
  typedef typename is_void<_To>::type type;
};

#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
template <typename _From, typename _To>
class __is_convertible_helper<_From, _To, false> {
  template <typename _To1>
  static void __test_aux(_To1) noexcept;

  template <typename _From1, typename _To1,
            typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
  static true_type __test(int);

  template <typename, typename>
  static false_type __test(...);

public:
  typedef decltype(__test<_From, _To>(0)) type;
};
#    pragma GCC diagnostic pop

/// is_convertible
template <typename _From, typename _To>
struct is_convertible : public __is_convertible_helper<_From, _To>::type {};
#  endif

// helper trait for unique_ptr<T[]>, shared_ptr<T[]>, and span<T, N>
template <typename _ToElementType, typename _FromElementType>
using __is_array_convertible = is_convertible<_FromElementType (*)[], _ToElementType (*)[]>;

#  if __cplusplus >= 202002L
#    define __cpp_lib_is_nothrow_convertible 201806L

#    if __has_builtin(__is_nothrow_convertible)
/// is_nothrow_convertible_v
template <typename _From, typename _To>
inline constexpr bool is_nothrow_convertible_v = __is_nothrow_convertible(_From, _To);

/// is_nothrow_convertible
template <typename _From, typename _To>
struct is_nothrow_convertible : public bool_constant<is_nothrow_convertible_v<_From, _To>> {};
#    else
template <typename _From, typename _To,
          bool = __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value>
struct __is_nt_convertible_helper : is_void<_To> {};

#      pragma GCC diagnostic push
#      pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
template <typename _From, typename _To>
class __is_nt_convertible_helper<_From, _To, false> {
  template <typename _To1>
  static void __test_aux(_To1) noexcept;

  template <typename _From1, typename _To1>
  static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))> __test(int);

  template <typename, typename>
  static false_type __test(...);

public:
  using type = decltype(__test<_From, _To>(0));
};
#      pragma GCC diagnostic pop

/// is_nothrow_convertible
template <typename _From, typename _To>
struct is_nothrow_convertible : public __is_nt_convertible_helper<_From, _To>::type {};

/// is_nothrow_convertible_v
template <typename _From, typename _To>
inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_From, _To>::value;
#    endif
#  endif // C++2a

// Const-volatile modifications.

/// remove_const
template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};

/// remove_volatile
template <typename _Tp>
struct remove_volatile {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_volatile<_Tp volatile> {
  typedef _Tp type;
};

/// remove_cv
#  if __has_builtin(__remove_cv)
template <typename _Tp>
struct remove_cv {
  using type = __remove_cv(_Tp);
};
#  else
template <typename _Tp>
struct remove_cv {
  using type = _Tp;
};

template <typename _Tp>
struct remove_cv<const _Tp> {
  using type = _Tp;
};

template <typename _Tp>
struct remove_cv<volatile _Tp> {
  using type = _Tp;
};

template <typename _Tp>
struct remove_cv<const volatile _Tp> {
  using type = _Tp;
};
#  endif

/// add_const
template <typename _Tp>
struct add_const {
  using type = _Tp const;
};

/// add_volatile
template <typename _Tp>
struct add_volatile {
  using type = _Tp volatile;
};

/// add_cv
template <typename _Tp>
struct add_cv {
  using type = _Tp const volatile;
};

#  if __cplusplus > 201103L

#    define __cpp_lib_transformation_trait_aliases 201304L

/// Alias template for remove_const
template <typename _Tp>
using remove_const_t = typename remove_const<_Tp>::type;

/// Alias template for remove_volatile
template <typename _Tp>
using remove_volatile_t = typename remove_volatile<_Tp>::type;

/// Alias template for remove_cv
template <typename _Tp>
using remove_cv_t = typename remove_cv<_Tp>::type;

/// Alias template for add_const
template <typename _Tp>
using add_const_t = typename add_const<_Tp>::type;

/// Alias template for add_volatile
template <typename _Tp>
using add_volatile_t = typename add_volatile<_Tp>::type;

/// Alias template for add_cv
template <typename _Tp>
using add_cv_t = typename add_cv<_Tp>::type;
#  endif

// Reference transformations.

/// remove_reference
#  if __has_builtin(__remove_reference)
template <typename _Tp>
struct remove_reference {
  using type = __remove_reference(_Tp);
};
#  else
template <typename _Tp>
struct remove_reference {
  using type = _Tp;
};

template <typename _Tp>
struct remove_reference<_Tp &> {
  using type = _Tp;
};

template <typename _Tp>
struct remove_reference<_Tp &&> {
  using type = _Tp;
};
#  endif

/// add_lvalue_reference
template <typename _Tp>
struct add_lvalue_reference {
  using type = __add_lval_ref_t<_Tp>;
};

/// add_rvalue_reference
template <typename _Tp>
struct add_rvalue_reference {
  using type = __add_rval_ref_t<_Tp>;
};

#  if __cplusplus > 201103L
/// Alias template for remove_reference
template <typename _Tp>
using remove_reference_t = typename remove_reference<_Tp>::type;

/// Alias template for add_lvalue_reference
template <typename _Tp>
using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;

/// Alias template for add_rvalue_reference
template <typename _Tp>
using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
#  endif

// Sign modifications.

/// @cond undocumented

// Utility for constructing identically cv-qualified types.
template <typename _Unqualified, bool _IsConst, bool _IsVol>
struct __cv_selector;

template <typename _Unqualified>
struct __cv_selector<_Unqualified, false, false> {
  typedef _Unqualified __type;
};

template <typename _Unqualified>
struct __cv_selector<_Unqualified, false, true> {
  typedef volatile _Unqualified __type;
};

template <typename _Unqualified>
struct __cv_selector<_Unqualified, true, false> {
  typedef const _Unqualified __type;
};

template <typename _Unqualified>
struct __cv_selector<_Unqualified, true, true> {
  typedef const volatile _Unqualified __type;
};

template <typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value,
          bool _IsVol = is_volatile<_Qualified>::value>
class __match_cv_qualifiers {
  typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

public:
  typedef typename __match::__type __type;
};

// Utility for finding the unsigned versions of signed integral types.
template <typename _Tp>
struct __make_unsigned {
  typedef _Tp __type;
};

template <>
struct __make_unsigned<char> {
  typedef unsigned char __type;
};

template <>
struct __make_unsigned<signed char> {
  typedef unsigned char __type;
};

template <>
struct __make_unsigned<short> {
  typedef unsigned short __type;
};

template <>
struct __make_unsigned<int> {
  typedef unsigned int __type;
};

template <>
struct __make_unsigned<long> {
  typedef unsigned long __type;
};

template <>
struct __make_unsigned<long long> {
  typedef unsigned long long __type;
};

#  if defined(__GLIBCXX_TYPE_INT_N_0)
__extension__ template <>
struct __make_unsigned<__GLIBCXX_TYPE_INT_N_0> {
  typedef unsigned __GLIBCXX_TYPE_INT_N_0 __type;
};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_1)
__extension__ template <>
struct __make_unsigned<__GLIBCXX_TYPE_INT_N_1> {
  typedef unsigned __GLIBCXX_TYPE_INT_N_1 __type;
};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_2)
__extension__ template <>
struct __make_unsigned<__GLIBCXX_TYPE_INT_N_2> {
  typedef unsigned __GLIBCXX_TYPE_INT_N_2 __type;
};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_3)
__extension__ template <>
struct __make_unsigned<__GLIBCXX_TYPE_INT_N_3> {
  typedef unsigned __GLIBCXX_TYPE_INT_N_3 __type;
};
#  endif

// Select between integral and enum: not possible to be both.
template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value>
class __make_unsigned_selector;

template <typename _Tp>
class __make_unsigned_selector<_Tp, true, false> {
  using __unsigned_type = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

public:
  using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
};

class __make_unsigned_selector_base {
protected:
  template <typename...>
  struct _List {};

  template <typename _Tp, typename... _Up>
  struct _List<_Tp, _Up...> : _List<_Up...> {
    static constexpr size_t __size = sizeof(_Tp);
  };

  template <size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
  struct __select;

  template <size_t _Sz, typename _Uint, typename... _UInts>
  struct __select<_Sz, _List<_Uint, _UInts...>, true> {
    using __type = _Uint;
  };

  template <size_t _Sz, typename _Uint, typename... _UInts>
  struct __select<_Sz, _List<_Uint, _UInts...>, false> : __select<_Sz, _List<_UInts...>> {};
};

// Choose unsigned integer type with the smallest rank and same size as _Tp
template <typename _Tp>
class __make_unsigned_selector<_Tp, false, true> : __make_unsigned_selector_base {
  // With -fshort-enums, an enum may be as small as a char.
  using _UInts =
      _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;

  using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

public:
  using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
};

// wchar_t, char8_t, char16_t and char32_t are integral types but are
// neither signed integer types nor unsigned integer types, so must be
// transformed to the unsigned integer type with the smallest rank.
// Use the partial specialization for enumeration types to do that.
template <>
struct __make_unsigned<wchar_t> {
  using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type;
};

#  ifdef _GLIBCXX_USE_CHAR8_T
template <>
struct __make_unsigned<char8_t> {
  using __type = typename __make_unsigned_selector<char8_t, false, true>::__type;
};
#  endif

template <>
struct __make_unsigned<char16_t> {
  using __type = typename __make_unsigned_selector<char16_t, false, true>::__type;
};

template <>
struct __make_unsigned<char32_t> {
  using __type = typename __make_unsigned_selector<char32_t, false, true>::__type;
};
/// @endcond

// Given an integral/enum type, return the corresponding unsigned
// integer type.
// Primary template.
/// make_unsigned
template <typename _Tp>
struct make_unsigned {
  typedef typename __make_unsigned_selector<_Tp>::__type type;
};

// Integral, but don't define.
template <>
struct make_unsigned<bool>;
template <>
struct make_unsigned<bool const>;
template <>
struct make_unsigned<bool volatile>;
template <>
struct make_unsigned<bool const volatile>;

/// @cond undocumented

// Utility for finding the signed versions of unsigned integral types.
template <typename _Tp>
struct __make_signed {
  typedef _Tp __type;
};

template <>
struct __make_signed<char> {
  typedef signed char __type;
};

template <>
struct __make_signed<unsigned char> {
  typedef signed char __type;
};

template <>
struct __make_signed<unsigned short> {
  typedef signed short __type;
};

template <>
struct __make_signed<unsigned int> {
  typedef signed int __type;
};

template <>
struct __make_signed<unsigned long> {
  typedef signed long __type;
};

template <>
struct __make_signed<unsigned long long> {
  typedef signed long long __type;
};

#  if defined(__GLIBCXX_TYPE_INT_N_0)
__extension__ template <>
struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_0> {
  typedef __GLIBCXX_TYPE_INT_N_0 __type;
};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_1)
__extension__ template <>
struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_1> {
  typedef __GLIBCXX_TYPE_INT_N_1 __type;
};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_2)
__extension__ template <>
struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_2> {
  typedef __GLIBCXX_TYPE_INT_N_2 __type;
};
#  endif
#  if defined(__GLIBCXX_TYPE_INT_N_3)
__extension__ template <>
struct __make_signed<unsigned __GLIBCXX_TYPE_INT_N_3> {
  typedef __GLIBCXX_TYPE_INT_N_3 __type;
};
#  endif

// Select between integral and enum: not possible to be both.
template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value>
class __make_signed_selector;

template <typename _Tp>
class __make_signed_selector<_Tp, true, false> {
  using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;

public:
  using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
};

// Choose signed integer type with the smallest rank and same size as _Tp
template <typename _Tp>
class __make_signed_selector<_Tp, false, true> {
  typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

public:
  typedef typename __make_signed_selector<__unsigned_type>::__type __type;
};

// wchar_t, char16_t and char32_t are integral types but are neither
// signed integer types nor unsigned integer types, so must be
// transformed to the signed integer type with the smallest rank.
// Use the partial specialization for enumeration types to do that.
template <>
struct __make_signed<wchar_t> {
  using __type = typename __make_signed_selector<wchar_t, false, true>::__type;
};

#  if defined(_GLIBCXX_USE_CHAR8_T)
template <>
struct __make_signed<char8_t> {
  using __type = typename __make_signed_selector<char8_t, false, true>::__type;
};
#  endif

template <>
struct __make_signed<char16_t> {
  using __type = typename __make_signed_selector<char16_t, false, true>::__type;
};

template <>
struct __make_signed<char32_t> {
  using __type = typename __make_signed_selector<char32_t, false, true>::__type;
};
/// @endcond

// Given an integral/enum type, return the corresponding signed
// integer type.
// Primary template.
/// make_signed
template <typename _Tp>
struct make_signed {
  typedef typename __make_signed_selector<_Tp>::__type type;
};

// Integral, but don't define.
template <>
struct make_signed<bool>;
template <>
struct make_signed<bool const>;
template <>
struct make_signed<bool volatile>;
template <>
struct make_signed<bool const volatile>;

#  if __cplusplus > 201103L
/// Alias template for make_signed
template <typename _Tp>
using make_signed_t = typename make_signed<_Tp>::type;

/// Alias template for make_unsigned
template <typename _Tp>
using make_unsigned_t = typename make_unsigned<_Tp>::type;
#  endif

// Array modifications.

/// remove_extent
template <typename _Tp>
struct remove_extent {
  typedef _Tp type;
};

template <typename _Tp, std::size_t _Size>
struct remove_extent<_Tp[_Size]> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_extent<_Tp[]> {
  typedef _Tp type;
};

/// remove_all_extents
template <typename _Tp>
struct remove_all_extents {
  typedef _Tp type;
};

template <typename _Tp, std::size_t _Size>
struct remove_all_extents<_Tp[_Size]> {
  typedef typename remove_all_extents<_Tp>::type type;
};

template <typename _Tp>
struct remove_all_extents<_Tp[]> {
  typedef typename remove_all_extents<_Tp>::type type;
};

#  if __cplusplus > 201103L
/// Alias template for remove_extent
template <typename _Tp>
using remove_extent_t = typename remove_extent<_Tp>::type;

/// Alias template for remove_all_extents
template <typename _Tp>
using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
#  endif

// Pointer modifications.

template <typename _Tp, typename>
struct __remove_pointer_helper {
  typedef _Tp type;
};

template <typename _Tp, typename _Up>
struct __remove_pointer_helper<_Tp, _Up *> {
  typedef _Up type;
};

/// remove_pointer
template <typename _Tp>
struct remove_pointer : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {};

template <typename _Tp, typename = void>
struct __add_pointer_helper {
  using type = _Tp;
};

template <typename _Tp>
struct __add_pointer_helper<_Tp, __void_t<_Tp *>> {
  using type = _Tp *;
};

/// add_pointer
template <typename _Tp>
struct add_pointer : public __add_pointer_helper<_Tp> {};

template <typename _Tp>
struct add_pointer<_Tp &> {
  using type = _Tp *;
};

template <typename _Tp>
struct add_pointer<_Tp &&> {
  using type = _Tp *;
};

#  if __cplusplus > 201103L
/// Alias template for remove_pointer
template <typename _Tp>
using remove_pointer_t = typename remove_pointer<_Tp>::type;

/// Alias template for add_pointer
template <typename _Tp>
using add_pointer_t = typename add_pointer<_Tp>::type;
#  endif

template <std::size_t _Len>
struct __aligned_storage_msa {
  union __type {
    unsigned char __data[_Len];
    struct __attribute__((__aligned__)) {
    } __align;
  };
};

/**
   *  @brief Alignment type.
   *
   *  The value of _Align is a default-alignment which shall be the
   *  most stringent alignment requirement for any C++ object type
   *  whose size is no greater than _Len (3.9). The member typedef
   *  type shall be a POD type suitable for use as uninitialized
   *  storage for any object whose size is at most _Len and whose
   *  alignment is a divisor of _Align.
   *
   *  @deprecated Deprecated in C++23. Uses can be replaced by an
   *  array std::byte[_Len] declared with alignas(_Align).
  */
template <std::size_t _Len,
          std::size_t _Align = __alignof__(typename __aligned_storage_msa<_Len>::__type)>
struct _GLIBCXX23_DEPRECATED aligned_storage {
  union type {
    unsigned char __data[_Len];
    struct __attribute__((__aligned__((_Align)))) {
    } __align;
  };
};

template <typename... _Types>
struct __strictest_alignment {
  static const size_t _S_alignment = 0;
  static const size_t _S_size      = 0;
};

template <typename _Tp, typename... _Types>
struct __strictest_alignment<_Tp, _Types...> {
  static const size_t _S_alignment = alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
                                         ? alignof(_Tp)
                                         : __strictest_alignment<_Types...>::_S_alignment;
  static const size_t _S_size      = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
                                         ? sizeof(_Tp)
                                         : __strictest_alignment<_Types...>::_S_size;
};

#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wdeprecated-declarations"

/**
   *  @brief Provide aligned storage for types.
   *
   *  [meta.trans.other]
   *
   *  Provides aligned storage for any of the provided types of at
   *  least size _Len.
   *
   *  @see aligned_storage
   *
   *  @deprecated Deprecated in C++23.
   */
template <size_t _Len, typename... _Types>
struct _GLIBCXX23_DEPRECATED aligned_union {
private:
  static_assert(sizeof...(_Types) != 0, "At least one type is required");

  using __strictest          = __strictest_alignment<_Types...>;
  static const size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;

public:
  /// The value of the strictest alignment of _Types.
  static const size_t alignment_value = __strictest::_S_alignment;
  /// The storage.
  typedef typename aligned_storage<_S_len, alignment_value>::type type;
};

template <size_t _Len, typename... _Types>
const size_t aligned_union<_Len, _Types...>::alignment_value;
#  pragma GCC diagnostic pop

/// @cond undocumented

// Decay trait for arrays and functions, used for perfect forwarding
// in make_pair, make_tuple, etc.
template <typename _Up>
struct __decay_selector : __conditional_t<is_const<const _Up>::value, // false for functions
                                          remove_cv<_Up>,             // N.B. DR 705.
                                          add_pointer<_Up>>           // function decays to pointer
{};

template <typename _Up, size_t _Nm>
struct __decay_selector<_Up[_Nm]> {
  using type = _Up *;
};

template <typename _Up>
struct __decay_selector<_Up[]> {
  using type = _Up *;
};

/// @endcond

/// decay
template <typename _Tp>
struct decay {
  using type = typename __decay_selector<_Tp>::type;
};

template <typename _Tp>
struct decay<_Tp &> {
  using type = typename __decay_selector<_Tp>::type;
};

template <typename _Tp>
struct decay<_Tp &&> {
  using type = typename __decay_selector<_Tp>::type;
};

/// @cond undocumented

// Helper which adds a reference to a type when given a reference_wrapper
template <typename _Tp>
struct __strip_reference_wrapper {
  typedef _Tp __type;
};

template <typename _Tp>
struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
  typedef _Tp &__type;
};

// __decay_t (std::decay_t for C++11).
template <typename _Tp>
using __decay_t = typename decay<_Tp>::type;

template <typename _Tp>
using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;
/// @endcond

/// @cond undocumented

// Helper for SFINAE constraints
template <typename... _Cond>
using _Require = __enable_if_t<__and_<_Cond...>::value>;

// __remove_cvref_t (std::remove_cvref_t for C++11).
template <typename _Tp>
using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
/// @endcond

// Primary template.
/// Define a member typedef @c type to one of two argument types.
template <bool _Cond, typename _Iftrue, typename _Iffalse>
struct conditional {
  typedef _Iftrue type;
};

// Partial specialization for false.
template <typename _Iftrue, typename _Iffalse>
struct conditional<false, _Iftrue, _Iffalse> {
  typedef _Iffalse type;
};

/// common_type
template <typename... _Tp>
struct common_type;

// Sfinae-friendly common_type implementation:

/// @cond undocumented

// For several sfinae-friendly trait implementations we transport both the
// result information (as the member type) and the failure information (no
// member type). This is very similar to std::enable_if, but we cannot use
// that, because we need to derive from them as an implementation detail.

template <typename _Tp>
struct __success_type {
  typedef _Tp type;
};

struct __failure_type {};

struct __do_common_type_impl {
  template <typename _Tp, typename _Up>
  using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());

  // if decay_t<decltype(false ? declval<D1>() : declval<D2>())>
  // denotes a valid type, let C denote that type.
  template <typename _Tp, typename _Up>
  static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);

#  if __cplusplus > 201703L
  // Otherwise, if COND-RES(CREF(D1), CREF(D2)) denotes a type,
  // let C denote the type decay_t<COND-RES(CREF(D1), CREF(D2))>.
  template <typename _Tp, typename _Up>
  static __success_type<__remove_cvref_t<__cond_t<const _Tp &, const _Up &>>> _S_test_2(int);
#  endif

  template <typename, typename>
  static __failure_type _S_test_2(...);

  template <typename _Tp, typename _Up>
  static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
};

// If sizeof...(T) is zero, there shall be no member type.
template <>
struct common_type<> {};

// If sizeof...(T) is one, the same type, if any, as common_type_t<T0, T0>.
template <typename _Tp0>
struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {};

// If sizeof...(T) is two, ...
template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>,
          typename _Dp2 = __decay_t<_Tp2>>
struct __common_type_impl {
  // If is_same_v<T1, D1> is false or is_same_v<T2, D2> is false,
  // let C denote the same type, if any, as common_type_t<D1, D2>.
  using type = common_type<_Dp1, _Dp2>;
};

template <typename _Tp1, typename _Tp2>
struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2> : private __do_common_type_impl {
  // Otherwise, if decay_t<decltype(false ? declval<D1>() : declval<D2>())>
  // denotes a valid type, let C denote that type.
  using type = decltype(_S_test<_Tp1, _Tp2>(0));
};

// If sizeof...(T) is two, ...
template <typename _Tp1, typename _Tp2>
struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {};

template <typename...>
struct __common_type_pack {};

template <typename, typename, typename = void>
struct __common_type_fold;

// If sizeof...(T) is greater than two, ...
template <typename _Tp1, typename _Tp2, typename... _Rp>
struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>, __common_type_pack<_Rp...>> {};

// Let C denote the same type, if any, as common_type_t<T1, T2>.
// If there is such a type C, type shall denote the same type, if any,
// as common_type_t<C, R...>.
template <typename _CTp, typename... _Rp>
struct __common_type_fold<_CTp, __common_type_pack<_Rp...>, __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...> {};

// Otherwise, there shall be no member type.
template <typename _CTp, typename _Rp>
struct __common_type_fold<_CTp, _Rp, void> {};

template <typename _Tp, bool = is_enum<_Tp>::value>
struct __underlying_type_impl {
  using type = __underlying_type(_Tp);
};

template <typename _Tp>
struct __underlying_type_impl<_Tp, false> {};
/// @endcond

/// The underlying type of an enum.
template <typename _Tp>
struct underlying_type : public __underlying_type_impl<_Tp> {};

/// @cond undocumented
template <typename _Tp>
struct __declval_protector {
  static const bool __stop = false;
};
/// @endcond

/** Utility to simplify expressions used in unevaluated operands
   *  @since C++11
   *  @ingroup utilities
   */
template <typename _Tp>
auto declval() noexcept -> decltype(__declval<_Tp>(0)) {
  static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
  return __declval<_Tp>(0);
}

/// result_of
template <typename _Signature>
struct result_of;

// Sfinae-friendly result_of implementation:

#  define __cpp_lib_result_of_sfinae 201210L

/// @cond undocumented
struct __invoke_memfun_ref {};
struct __invoke_memfun_deref {};
struct __invoke_memobj_ref {};
struct __invoke_memobj_deref {};
struct __invoke_other {};

// Associate a tag type with a specialization of __success_type.
template <typename _Tp, typename _Tag>
struct __result_of_success : __success_type<_Tp> {
  using __invoke_type = _Tag;
};

// [func.require] paragraph 1 bullet 1:
struct __result_of_memfun_ref_impl {
  template <typename _Fp, typename _Tp1, typename... _Args>
  static __result_of_success<decltype((std::declval<_Tp1>().*
                                       std::declval<_Fp>())(std::declval<_Args>()...)),
                             __invoke_memfun_ref>
  _S_test(int);

  template <typename...>
  static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_memfun_ref : private __result_of_memfun_ref_impl {
  typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
};

// [func.require] paragraph 1 bullet 2:
struct __result_of_memfun_deref_impl {
  template <typename _Fp, typename _Tp1, typename... _Args>
  static __result_of_success<decltype(((*std::declval<_Tp1>()).*
                                       std::declval<_Fp>())(std::declval<_Args>()...)),
                             __invoke_memfun_deref>
  _S_test(int);

  template <typename...>
  static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_memfun_deref : private __result_of_memfun_deref_impl {
  typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
};

// [func.require] paragraph 1 bullet 3:
struct __result_of_memobj_ref_impl {
  template <typename _Fp, typename _Tp1>
  static __result_of_success<decltype(std::declval<_Tp1>().*std::declval<_Fp>()),
                             __invoke_memobj_ref>
  _S_test(int);

  template <typename, typename>
  static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg>
struct __result_of_memobj_ref : private __result_of_memobj_ref_impl {
  typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
};

// [func.require] paragraph 1 bullet 4:
struct __result_of_memobj_deref_impl {
  template <typename _Fp, typename _Tp1>
  static __result_of_success<decltype((*std::declval<_Tp1>()).*std::declval<_Fp>()),
                             __invoke_memobj_deref>
  _S_test(int);

  template <typename, typename>
  static __failure_type _S_test(...);
};

template <typename _MemPtr, typename _Arg>
struct __result_of_memobj_deref : private __result_of_memobj_deref_impl {
  typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
};

template <typename _MemPtr, typename _Arg>
struct __result_of_memobj;

template <typename _Res, typename _Class, typename _Arg>
struct __result_of_memobj<_Res _Class::*, _Arg> {
  typedef __remove_cvref_t<_Arg> _Argval;
  typedef _Res _Class::*_MemPtr;
  typedef
      typename __conditional_t<__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value,
                               __result_of_memobj_ref<_MemPtr, _Arg>,
                               __result_of_memobj_deref<_MemPtr, _Arg>>::type type;
};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_memfun;

template <typename _Res, typename _Class, typename _Arg, typename... _Args>
struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
  typedef typename remove_reference<_Arg>::type _Argval;
  typedef _Res _Class::                                                                    *_MemPtr;
  typedef typename __conditional_t<is_base_of<_Class, _Argval>::value,
                                   __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
                                   __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type type;
};

// _GLIBCXX_RESOLVE_LIB_DEFECTS
// 2219.  INVOKE-ing a pointer to member with a reference_wrapper
//        as the object expression

// Used by result_of, invoke etc. to unwrap a reference_wrapper.
template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
struct __inv_unwrap {
  using type = _Tp;
};

template <typename _Tp, typename _Up>
struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
  using type = _Up &;
};

template <bool, bool, typename _Functor, typename... _ArgTypes>
struct __result_of_impl {
  typedef __failure_type type;
};

template <typename _MemPtr, typename _Arg>
struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type> {};

template <typename _MemPtr, typename _Arg, typename... _Args>
struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>, typename __inv_unwrap<_Arg>::type, _Args...> {};

// [func.require] paragraph 1 bullet 5:
struct __result_of_other_impl {
  template <typename _Fn, typename... _Args>
  static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)),
                             __invoke_other>
  _S_test(int);

  template <typename...>
  static __failure_type _S_test(...);
};

template <typename _Functor, typename... _ArgTypes>
struct __result_of_impl<false, false, _Functor, _ArgTypes...> : private __result_of_other_impl {
  typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
};

// __invoke_result (std::invoke_result for C++11)
template <typename _Functor, typename... _ArgTypes>
struct __invoke_result
    : public __result_of_impl<
          is_member_object_pointer<typename remove_reference<_Functor>::type>::value,
          is_member_function_pointer<typename remove_reference<_Functor>::type>::value, _Functor,
          _ArgTypes...>::type {};
/// @endcond

template <typename _Functor, typename... _ArgTypes>
struct result_of<_Functor(_ArgTypes...)> : public __invoke_result<_Functor, _ArgTypes...> {
} _GLIBCXX17_DEPRECATED_SUGGEST("std::invoke_result");

#  if __cplusplus >= 201402L
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wdeprecated-declarations"
/// Alias template for aligned_storage
template <size_t _Len, size_t _Align = __alignof__(typename __aligned_storage_msa<_Len>::__type)>
using aligned_storage_t _GLIBCXX23_DEPRECATED = typename aligned_storage<_Len, _Align>::type;

template <size_t _Len, typename... _Types>
using aligned_union_t _GLIBCXX23_DEPRECATED = typename aligned_union<_Len, _Types...>::type;
#    pragma GCC diagnostic pop

/// Alias template for decay
template <typename _Tp>
using decay_t = typename decay<_Tp>::type;

/// Alias template for enable_if
template <bool _Cond, typename _Tp = void>
using enable_if_t = typename enable_if<_Cond, _Tp>::type;

/// Alias template for conditional
template <bool _Cond, typename _Iftrue, typename _Iffalse>
using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;

/// Alias template for common_type
template <typename... _Tp>
using common_type_t = typename common_type<_Tp...>::type;

/// Alias template for underlying_type
template <typename _Tp>
using underlying_type_t = typename underlying_type<_Tp>::type;

/// Alias template for result_of
template <typename _Tp>
using result_of_t = typename result_of<_Tp>::type;
#  endif // C++14

#  if __cplusplus >= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++11
#    define __cpp_lib_void_t 201411L
/// A metafunction that always yields void, used for detecting valid types.
template <typename...>
using void_t = void;
#  endif

/// @cond undocumented

// Detection idiom.
// Detect whether _Op<_Args...> is a valid type, use default _Def if not.

#  if __cpp_concepts
// Implementation of the detection idiom (negative case).
template <typename _Def, template <typename...> class _Op, typename... _Args>
struct __detected_or {
  using type          = _Def;
  using __is_detected = false_type;
};

// Implementation of the detection idiom (positive case).
template <typename _Def, template <typename...> class _Op, typename... _Args>
requires requires { typename _Op<_Args...>; }
struct __detected_or<_Def, _Op, _Args...> {
  using type          = _Op<_Args...>;
  using __is_detected = true_type;
};
#  else
/// Implementation of the detection idiom (negative case).
template <typename _Default, typename _AlwaysVoid, template <typename...> class _Op,
          typename... _Args>
struct __detector {
  using type          = _Default;
  using __is_detected = false_type;
};

/// Implementation of the detection idiom (positive case).
template <typename _Default, template <typename...> class _Op, typename... _Args>
struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...> {
  using type          = _Op<_Args...>;
  using __is_detected = true_type;
};

template <typename _Default, template <typename...> class _Op, typename... _Args>
using __detected_or = __detector<_Default, void, _Op, _Args...>;
#  endif // __cpp_concepts

// _Op<_Args...> if that is a valid type, otherwise _Default.
template <typename _Default, template <typename...> class _Op, typename... _Args>
using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;

/**
   *  Use SFINAE to determine if the type _Tp has a publicly-accessible
   *  member type _NTYPE.
   */
#  define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE)                                                         \
    template <typename _Tp, typename = __void_t<>>                                                 \
    struct __has_##_NTYPE : false_type {};                                                         \
    template <typename _Tp>                                                                        \
    struct __has_##_NTYPE<_Tp, __void_t<typename _Tp::_NTYPE>> : true_type {};

template <typename _Tp>
struct __is_swappable;

template <typename _Tp>
struct __is_nothrow_swappable;

template <typename>
struct __is_tuple_like_impl : false_type {};

// Internal type trait that allows us to sfinae-protect tuple_cat.
template <typename _Tp>
struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {};
/// @endcond

template <typename _Tp>
_GLIBCXX20_CONSTEXPR inline _Require<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>,
                                     is_move_assignable<_Tp>>
swap(_Tp &, _Tp &) noexcept(
    __and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value);

template <typename _Tp, size_t _Nm>
_GLIBCXX20_CONSTEXPR inline __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);

/// @cond undocumented
namespace __swappable_details {
using std::swap;

struct __do_is_swappable_impl {
  template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))>
  static true_type __test(int);

  template <typename>
  static false_type __test(...);
};

struct __do_is_nothrow_swappable_impl {
  template <typename _Tp>
  static __bool_constant<noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> __test(int);

  template <typename>
  static false_type __test(...);
};

} // namespace __swappable_details

template <typename _Tp>
struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl {
  typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp>
struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl {
  typedef decltype(__test<_Tp>(0)) type;
};

template <typename _Tp>
struct __is_swappable : public __is_swappable_impl<_Tp>::type {};

template <typename _Tp>
struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {};
/// @endcond

#  if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
#    define __cpp_lib_is_swappable 201603L
/// Metafunctions used for detecting swappable types: p0185r1

/// is_swappable
template <typename _Tp>
struct is_swappable : public __is_swappable_impl<_Tp>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// is_nothrow_swappable
template <typename _Tp>
struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

#    if __cplusplus >= 201402L
/// is_swappable_v
template <typename _Tp>
_GLIBCXX17_INLINE constexpr bool is_swappable_v = is_swappable<_Tp>::value;

/// is_nothrow_swappable_v
template <typename _Tp>
_GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
#    endif // __cplusplus >= 201402L

/// @cond undocumented
namespace __swappable_with_details {
using std::swap;

struct __do_is_swappable_with_impl {
  template <typename _Tp, typename _Up,
            typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
            typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
  static true_type __test(int);

  template <typename, typename>
  static false_type __test(...);
};

struct __do_is_nothrow_swappable_with_impl {
  template <typename _Tp, typename _Up>
  static __bool_constant<noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) &&
                         noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))>
  __test(int);

  template <typename, typename>
  static false_type __test(...);
};

} // namespace __swappable_with_details

template <typename _Tp, typename _Up>
struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl {
  typedef decltype(__test<_Tp, _Up>(0)) type;
};

// Optimization for the homogenous lvalue case, not required:
template <typename _Tp>
struct __is_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_swappable_impl {
  typedef decltype(__test<_Tp &>(0)) type;
};

template <typename _Tp, typename _Up>
struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
  typedef decltype(__test<_Tp, _Up>(0)) type;
};

// Optimization for the homogenous lvalue case, not required:
template <typename _Tp>
struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &>
    : public __swappable_details::__do_is_nothrow_swappable_impl {
  typedef decltype(__test<_Tp &>(0)) type;
};
/// @endcond

/// is_swappable_with
template <typename _Tp, typename _Up>
struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "first template argument must be a complete class or an unbounded array");
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                "second template argument must be a complete class or an unbounded array");
};

/// is_nothrow_swappable_with
template <typename _Tp, typename _Up>
struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "first template argument must be a complete class or an unbounded array");
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                "second template argument must be a complete class or an unbounded array");
};

#    if __cplusplus >= 201402L
/// is_swappable_with_v
template <typename _Tp, typename _Up>
_GLIBCXX17_INLINE constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;

/// is_nothrow_swappable_with_v
template <typename _Tp, typename _Up>
_GLIBCXX17_INLINE constexpr bool is_nothrow_swappable_with_v =
    is_nothrow_swappable_with<_Tp, _Up>::value;
#    endif // __cplusplus >= 201402L

#  endif // c++1z or gnu++11

/// @cond undocumented

// __is_invocable (std::is_invocable for C++11)

// The primary template is used for invalid INVOKE expressions.
template <typename _Result, typename _Ret, bool = is_void<_Ret>::value, typename = void>
struct __is_invocable_impl : false_type {
  using __nothrow_conv = false_type; // For is_nothrow_invocable_r
};

// Used for valid INVOKE and INVOKE<void> expressions.
template <typename _Result, typename _Ret>
struct __is_invocable_impl<_Result, _Ret,
                           /* is_void<_Ret> = */ true, __void_t<typename _Result::type>>
    : true_type {
  using __nothrow_conv = true_type; // For is_nothrow_invocable_r
};

#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
// Used for INVOKE<R> expressions to check the implicit conversion to R.
template <typename _Result, typename _Ret>
struct __is_invocable_impl<_Result, _Ret,
                           /* is_void<_Ret> = */ false, __void_t<typename _Result::type>> {
private:
  // The type of the INVOKE expression.
  using _Res_t = typename _Result::type;

  // Unlike declval, this doesn't add_rvalue_reference, so it respects
  // guaranteed copy elision.
  static _Res_t _S_get() noexcept;

  // Used to check if _Res_t can implicitly convert to _Tp.
  template <typename _Tp>
  static void _S_conv(__type_identity_t<_Tp>) noexcept;

  // This overload is viable if INVOKE(f, args...) can convert to _Tp.
  template <typename _Tp, bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
            typename     = decltype(_S_conv<_Tp>(_S_get())),
#  if __has_builtin(__reference_converts_from_temporary)
            bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)
#  else
            bool _Dangle = false
#  endif
            >
  static __bool_constant<_Nothrow && !_Dangle> _S_test(int);

  template <typename _Tp, bool = false>
  static false_type _S_test(...);

public:
  // For is_invocable_r
  using type = decltype(_S_test<_Ret, /* Nothrow = */ true>(1));

  // For is_nothrow_invocable_r
  using __nothrow_conv = decltype(_S_test<_Ret>(1));
};
#  pragma GCC diagnostic pop

template <typename _Fn, typename... _ArgTypes>
struct __is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {};

template <typename _Fn, typename _Tp, typename... _Args>
constexpr bool __call_is_nt(__invoke_memfun_ref) {
  using _Up = typename __inv_unwrap<_Tp>::type;
  return noexcept((std::declval<_Up>().*std::declval<_Fn>())(std::declval<_Args>()...));
}

template <typename _Fn, typename _Tp, typename... _Args>
constexpr bool __call_is_nt(__invoke_memfun_deref) {
  return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(std::declval<_Args>()...));
}

template <typename _Fn, typename _Tp>
constexpr bool __call_is_nt(__invoke_memobj_ref) {
  using _Up = typename __inv_unwrap<_Tp>::type;
  return noexcept(std::declval<_Up>().*std::declval<_Fn>());
}

template <typename _Fn, typename _Tp>
constexpr bool __call_is_nt(__invoke_memobj_deref) {
  return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
}

template <typename _Fn, typename... _Args>
constexpr bool __call_is_nt(__invoke_other) {
  return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
}

template <typename _Result, typename _Fn, typename... _Args>
struct __call_is_nothrow
    : __bool_constant<std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})> {};

template <typename _Fn, typename... _Args>
using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;

// __is_nothrow_invocable (std::is_nothrow_invocable for C++11)
template <typename _Fn, typename... _Args>
struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>, __call_is_nothrow_<_Fn, _Args...>>::type {};

#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
struct __nonesuchbase {};
struct __nonesuch : private __nonesuchbase {
  ~__nonesuch()                      = delete;
  __nonesuch(__nonesuch const &)     = delete;
  void operator=(__nonesuch const &) = delete;
};
#  pragma GCC diagnostic pop
/// @endcond

#  if __cplusplus >= 201703L
#    define __cpp_lib_is_invocable 201703L

/// std::invoke_result
template <typename _Functor, typename... _ArgTypes>
struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
                "_Functor must be a complete class or an unbounded array");
  static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
                "each argument type must be a complete class or an unbounded array");
};

/// std::invoke_result_t
template <typename _Fn, typename... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;

/// std::is_invocable
template <typename _Fn, typename... _ArgTypes>
struct is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                "_Fn must be a complete class or an unbounded array");
  static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
                "each argument type must be a complete class or an unbounded array");
};

/// std::is_invocable_r
template <typename _Ret, typename _Fn, typename... _ArgTypes>
struct is_invocable_r : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                "_Fn must be a complete class or an unbounded array");
  static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
                "each argument type must be a complete class or an unbounded array");
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
                "_Ret must be a complete class or an unbounded array");
};

/// std::is_nothrow_invocable
template <typename _Fn, typename... _ArgTypes>
struct is_nothrow_invocable : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
                                     __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                "_Fn must be a complete class or an unbounded array");
  static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
                "each argument type must be a complete class or an unbounded array");
};

/// @cond undocumented
// This checks that the INVOKE<R> expression is well-formed and that the
// conversion to R does not throw. It does *not* check whether the INVOKE
// expression itself can throw. That is done by __call_is_nothrow_ instead.
template <typename _Result, typename _Ret>
using __is_nt_invocable_impl = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;
/// @endcond

/// std::is_nothrow_invocable_r
template <typename _Ret, typename _Fn, typename... _ArgTypes>
struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                "_Fn must be a complete class or an unbounded array");
  static_assert((std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
                "each argument type must be a complete class or an unbounded array");
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
                "_Ret must be a complete class or an unbounded array");
};
#  endif // C++17

#  if __cplusplus >= 201703L
#    define __cpp_lib_type_trait_variable_templates 201510L
/**
   * @defgroup variable_templates Variable templates for type traits
   * @ingroup metaprogramming
   *
   * Each variable `is_xxx_v<T>` is a boolean constant with the same value
   * as the `value` member of the corresponding type trait `is_xxx<T>`.
   *
   * @since C++17 unless noted otherwise.
   */

/**
   * @{
   * @ingroup variable_templates
   */
template <typename _Tp>
inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;

template <typename _Tp>
inline constexpr bool is_array_v = false;
template <typename _Tp>
inline constexpr bool is_array_v<_Tp[]> = true;
template <typename _Tp, size_t _Num>
inline constexpr bool is_array_v<_Tp[_Num]> = true;

template <typename _Tp>
inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_lvalue_reference_v = false;
template <typename _Tp>
inline constexpr bool is_lvalue_reference_v<_Tp &> = true;
template <typename _Tp>
inline constexpr bool is_rvalue_reference_v = false;
template <typename _Tp>
inline constexpr bool is_rvalue_reference_v<_Tp &&> = true;
template <typename _Tp>
inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_enum_v = __is_enum(_Tp);
template <typename _Tp>
inline constexpr bool is_union_v = __is_union(_Tp);
template <typename _Tp>
inline constexpr bool is_class_v = __is_class(_Tp);
template <typename _Tp>
inline constexpr bool is_function_v = is_function<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_reference_v = false;
template <typename _Tp>
inline constexpr bool is_reference_v<_Tp &> = true;
template <typename _Tp>
inline constexpr bool is_reference_v<_Tp &&> = true;
template <typename _Tp>
inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_object_v = is_object<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_compound_v = is_compound<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_const_v = false;
template <typename _Tp>
inline constexpr bool is_const_v<const _Tp> = true;
template <typename _Tp>
inline constexpr bool is_volatile_v = false;
template <typename _Tp>
inline constexpr bool is_volatile_v<volatile _Tp> = true;

template <typename _Tp>
inline constexpr bool is_trivial_v = __is_trivial(_Tp);
template <typename _Tp>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
template <typename _Tp>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
template <typename _Tp>
_GLIBCXX20_DEPRECATED_SUGGEST("is_standard_layout_v && is_trivial_v")
inline constexpr bool is_pod_v = __is_pod(_Tp);
template <typename _Tp>
_GLIBCXX17_DEPRECATED inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
template <typename _Tp>
inline constexpr bool is_empty_v = __is_empty(_Tp);
template <typename _Tp>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
template <typename _Tp>
inline constexpr bool is_abstract_v = __is_abstract(_Tp);
template <typename _Tp>
inline constexpr bool is_final_v = __is_final(_Tp);

template <typename _Tp>
inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

template <typename _Tp, typename... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
template <typename _Tp>
inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
template <typename _Tp>
inline constexpr bool is_copy_constructible_v =
    __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
inline constexpr bool is_move_constructible_v = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
template <typename _Tp>
inline constexpr bool is_copy_assignable_v =
    __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
inline constexpr bool is_move_assignable_v =
    __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

template <typename _Tp, typename... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Tp, _Args...);
template <typename _Tp>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Tp);
template <typename _Tp>
inline constexpr bool is_trivially_copy_constructible_v =
    __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
inline constexpr bool is_trivially_move_constructible_v =
    __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_Tp, _Up);
template <typename _Tp>
inline constexpr bool is_trivially_copy_assignable_v =
    __is_trivially_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
inline constexpr bool is_trivially_move_assignable_v =
    __is_trivially_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);
template <typename _Tp>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Tp, _Args...);
template <typename _Tp>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Tp);
template <typename _Tp>
inline constexpr bool is_nothrow_copy_constructible_v =
    __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
inline constexpr bool is_nothrow_move_constructible_v =
    __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_Tp, _Up);
template <typename _Tp>
inline constexpr bool is_nothrow_copy_assignable_v =
    __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
inline constexpr bool is_nothrow_move_assignable_v =
    __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;

template <typename _Tp>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Tp);

template <typename _Tp>
inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

template <typename _Tp>
inline constexpr size_t rank_v = 0;
template <typename _Tp, size_t _Size>
inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
template <typename _Tp>
inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

template <typename _Tp, unsigned _Idx = 0>
inline constexpr size_t extent_v = 0;
template <typename _Tp, size_t _Size>
inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
template <typename _Tp, unsigned _Idx, size_t _Size>
inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
template <typename _Tp>
inline constexpr size_t extent_v<_Tp[], 0> = 0;
template <typename _Tp, unsigned _Idx>
inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;

#    ifdef _GLIBCXX_HAVE_BUILTIN_IS_SAME
template <typename _Tp, typename _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);
#    else
template <typename _Tp, typename _Up>
inline constexpr bool is_same_v = false;
template <typename _Tp>
inline constexpr bool is_same_v<_Tp, _Tp> = true;
#    endif
template <typename _Base, typename _Derived>
inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
#    if __has_builtin(__is_convertible)
template <typename _From, typename _To>
inline constexpr bool is_convertible_v = __is_convertible(_From, _To);
#    else
template <typename _From, typename _To>
inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
#    endif
template <typename _Fn, typename... _Args>
inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template <typename _Fn, typename... _Args>
inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
template <typename _Ret, typename _Fn, typename... _Args>
inline constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
template <typename _Ret, typename _Fn, typename... _Args>
inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
/// @}

#    ifdef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP
#      define __cpp_lib_has_unique_object_representations 201606L
/// has_unique_object_representations
/// @since C++17
template <typename _Tp>
struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @ingroup variable_templates
template <typename _Tp>
inline constexpr bool has_unique_object_representations_v =
    has_unique_object_representations<_Tp>::value;
#    endif

#    ifdef _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE
#      define __cpp_lib_is_aggregate 201703L
/// is_aggregate - true if the type is an aggregate.
/// @since C++17
template <typename _Tp>
struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {};

/** is_aggregate_v - true if the type is an aggregate.
   *  @ingroup variable_templates
   *  @since C++17
   */
template <typename _Tp>
inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
#    endif
#  endif // C++17

#  if __cplusplus >= 202002L

/** * Remove references and cv-qualifiers.
   * @since C++20
   * @{
   */
#    define __cpp_lib_remove_cvref 201711L

#    if __has_builtin(__remove_cvref)
template <typename _Tp>
struct remove_cvref {
  using type = __remove_cvref(_Tp);
};
#    else
template <typename _Tp>
struct remove_cvref {
  using type = typename remove_cv<_Tp>::type;
};

template <typename _Tp>
struct remove_cvref<_Tp &> {
  using type = typename remove_cv<_Tp>::type;
};

template <typename _Tp>
struct remove_cvref<_Tp &&> {
  using type = typename remove_cv<_Tp>::type;
};
#    endif

template <typename _Tp>
using remove_cvref_t = typename remove_cvref<_Tp>::type;
/// @}

/** * Identity metafunction.
   * @since C++20
   * @{
   */
#    define __cpp_lib_type_identity 201806L
template <typename _Tp>
struct type_identity {
  using type = _Tp;
};

template <typename _Tp>
using type_identity_t = typename type_identity<_Tp>::type;
/// @}

#    define __cpp_lib_unwrap_ref 201811L

/** Unwrap a reference_wrapper
   * @since C++20
   * @{
   */
template <typename _Tp>
struct unwrap_reference {
  using type = _Tp;
};

template <typename _Tp>
struct unwrap_reference<reference_wrapper<_Tp>> {
  using type = _Tp &;
};

template <typename _Tp>
using unwrap_reference_t = typename unwrap_reference<_Tp>::type;
/// @}

/** Decay type and if it's a reference_wrapper, unwrap it
   * @since C++20
   * @{
   */
template <typename _Tp>
struct unwrap_ref_decay {
  using type = unwrap_reference_t<decay_t<_Tp>>;
};

template <typename _Tp>
using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
/// @}

#    define __cpp_lib_bounded_array_traits 201902L

/// True for a type that is an array of known bound.
/// @ingroup variable_templates
/// @since C++20
template <typename _Tp>
inline constexpr bool is_bounded_array_v = false;

template <typename _Tp, size_t _Size>
inline constexpr bool is_bounded_array_v<_Tp[_Size]> = true;

/// True for a type that is an array of unknown bound.
/// @ingroup variable_templates
/// @since C++20
template <typename _Tp>
inline constexpr bool is_unbounded_array_v = false;

template <typename _Tp>
inline constexpr bool is_unbounded_array_v<_Tp[]> = true;

/// True for a type that is an array of known bound.
/// @since C++20
template <typename _Tp>
struct is_bounded_array : public bool_constant<is_bounded_array_v<_Tp>> {};

/// True for a type that is an array of unknown bound.
/// @since C++20
template <typename _Tp>
struct is_unbounded_array : public bool_constant<is_unbounded_array_v<_Tp>> {};

#    if __has_builtin(__is_layout_compatible)

/// @since C++20
template <typename _Tp, typename _Up>
struct is_layout_compatible : bool_constant<__is_layout_compatible(_Tp, _Up)> {};

/// @ingroup variable_templates
/// @since C++20
template <typename _Tp, typename _Up>
constexpr bool is_layout_compatible_v = __is_layout_compatible(_Tp, _Up);

#      if __has_builtin(__builtin_is_corresponding_member)
#        define __cpp_lib_is_layout_compatible 201907L

/// @since C++20
template <typename _S1, typename _S2, typename _M1, typename _M2>
constexpr bool is_corresponding_member(_M1 _S1::*__m1, _M2 _S2::*__m2) noexcept {
  return __builtin_is_corresponding_member(__m1, __m2);
}
#      endif
#    endif

#    if __has_builtin(__is_pointer_interconvertible_base_of)
/// True if `_Derived` is standard-layout and has a base class of type `_Base`
/// @since C++20
template <typename _Base, typename _Derived>
struct is_pointer_interconvertible_base_of
    : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)> {};

/// @ingroup variable_templates
/// @since C++20
template <typename _Base, typename _Derived>
constexpr bool is_pointer_interconvertible_base_of_v =
    __is_pointer_interconvertible_base_of(_Base, _Derived);

#      if __has_builtin(__builtin_is_pointer_interconvertible_with_class)
#        define __cpp_lib_is_pointer_interconvertible 201907L

/// True if `__mp` points to the first member of a standard-layout type
/// @returns true if `s.*__mp` is pointer-interconvertible with `s`
/// @since C++20
template <typename _Tp, typename _Mem>
constexpr bool is_pointer_interconvertible_with_class(_Mem _Tp::*__mp) noexcept {
  return __builtin_is_pointer_interconvertible_with_class(__mp);
}
#      endif
#    endif

#    if __cplusplus > 202002L
#      define __cpp_lib_is_scoped_enum 202011L

/// True if the type is a scoped enumeration type.
/// @since C++23

template <typename _Tp>
struct is_scoped_enum : false_type {};

template <typename _Tp>
requires __is_enum(_Tp) &&
         requires(remove_cv_t<_Tp> __t) { __t = __t; } // fails if incomplete
         struct is_scoped_enum<_Tp> : bool_constant < !requires(_Tp __t, void (*__f)(int)) {
  __f(__t);
} > {};

/// @ingroup variable_templates
/// @since C++23
template <typename _Tp>
inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Tp>::value;

#      if __has_builtin(__reference_constructs_from_temporary) &&                                  \
          __has_builtin(__reference_converts_from_temporary)

#        define __cpp_lib_reference_from_temporary 202202L

/// True if _Tp is a reference type, a _Up value can be bound to _Tp in
/// direct-initialization, and a temporary object would be bound to
/// the reference, false otherwise.
/// @since C++23
template <typename _Tp, typename _Up>
struct reference_constructs_from_temporary
    : public bool_constant<__reference_constructs_from_temporary(_Tp, _Up)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}) &&
                    std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                "template argument must be a complete class or an unbounded array");
};

/// True if _Tp is a reference type, a _Up value can be bound to _Tp in
/// copy-initialization, and a temporary object would be bound to
/// the reference, false otherwise.
/// @since C++23
template <typename _Tp, typename _Up>
struct reference_converts_from_temporary
    : public bool_constant<__reference_converts_from_temporary(_Tp, _Up)> {
  static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}) &&
                    std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                "template argument must be a complete class or an unbounded array");
};

/// @ingroup variable_templates
/// @since C++23
template <typename _Tp, typename _Up>
inline constexpr bool reference_constructs_from_temporary_v =
    reference_constructs_from_temporary<_Tp, _Up>::value;

/// @ingroup variable_templates
/// @since C++23
template <typename _Tp, typename _Up>
inline constexpr bool reference_converts_from_temporary_v =
    reference_converts_from_temporary<_Tp, _Up>::value;
#      endif // __has_builtin for reference_from_temporary
#    endif   // C++23

#    if _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED
#      define __cpp_lib_is_constant_evaluated 201811L

/// Returns true only when called during constant evaluation.
/// @since C++20
constexpr inline bool is_constant_evaluated() noexcept {
#      if __cpp_if_consteval >= 202106L
  if consteval {
    return true;
  } else {
    return false;
  }
#      else
  return __builtin_is_constant_evaluated();
#      endif
}
#    endif

/// @cond undocumented
template <typename _From, typename _To>
using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;

template <typename _Xp, typename _Yp>
using __cond_res = decltype(false ? declval<_Xp (&)()>()() : declval<_Yp (&)()>()());

template <typename _Ap, typename _Bp, typename = void>
struct __common_ref_impl {};

// [meta.trans.other], COMMON-REF(A, B)
template <typename _Ap, typename _Bp>
using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;

// COND-RES(COPYCV(X, Y) &, COPYCV(Y, X) &)
template <typename _Xp, typename _Yp>
using __condres_cvref = __cond_res<__copy_cv<_Xp, _Yp> &, __copy_cv<_Yp, _Xp> &>;

// If A and B are both lvalue reference types, ...
template <typename _Xp, typename _Yp>
struct __common_ref_impl<_Xp &, _Yp &, __void_t<__condres_cvref<_Xp, _Yp>>>
    : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>, __condres_cvref<_Xp, _Yp>> {};

// let C be remove_reference_t<COMMON-REF(X&, Y&)>&&
template <typename _Xp, typename _Yp>
using __common_ref_C = remove_reference_t<__common_ref<_Xp &, _Yp &>> &&;

// If A and B are both rvalue reference types, ...
template <typename _Xp, typename _Yp>
struct __common_ref_impl<_Xp &&, _Yp &&,
                         _Require<is_convertible<_Xp &&, __common_ref_C<_Xp, _Yp>>,
                                  is_convertible<_Yp &&, __common_ref_C<_Xp, _Yp>>>> {
  using type = __common_ref_C<_Xp, _Yp>;
};

// let D be COMMON-REF(const X&, Y&)
template <typename _Xp, typename _Yp>
using __common_ref_D = __common_ref<const _Xp &, _Yp &>;

// If A is an rvalue reference and B is an lvalue reference, ...
template <typename _Xp, typename _Yp>
struct __common_ref_impl<_Xp &&, _Yp &,
                         _Require<is_convertible<_Xp &&, __common_ref_D<_Xp, _Yp>>>> {
  using type = __common_ref_D<_Xp, _Yp>;
};

// If A is an lvalue reference and B is an rvalue reference, ...
template <typename _Xp, typename _Yp>
struct __common_ref_impl<_Xp &, _Yp &&> : __common_ref_impl<_Yp &&, _Xp &> {};
/// @endcond

template <typename _Tp, typename _Up, template <typename> class _TQual,
          template <typename> class _UQual>
struct basic_common_reference {};

/// @cond undocumented
template <typename _Tp>
struct __xref {
  template <typename _Up>
  using __type = __copy_cv<_Tp, _Up>;
};

template <typename _Tp>
struct __xref<_Tp &> {
  template <typename _Up>
  using __type = __copy_cv<_Tp, _Up> &;
};

template <typename _Tp>
struct __xref<_Tp &&> {
  template <typename _Up>
  using __type = __copy_cv<_Tp, _Up> &&;
};

template <typename _Tp1, typename _Tp2>
using __basic_common_ref =
    typename basic_common_reference<remove_cvref_t<_Tp1>, remove_cvref_t<_Tp2>,
                                    __xref<_Tp1>::template __type,
                                    __xref<_Tp2>::template __type>::type;
/// @endcond

template <typename... _Tp>
struct common_reference;

template <typename... _Tp>
using common_reference_t = typename common_reference<_Tp...>::type;

// If sizeof...(T) is zero, there shall be no member type.
template <>
struct common_reference<> {};

// If sizeof...(T) is one ...
template <typename _Tp0>
struct common_reference<_Tp0> {
  using type = _Tp0;
};

/// @cond undocumented
template <typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>
struct __common_reference_impl : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1> {};

// If sizeof...(T) is two ...
template <typename _Tp1, typename _Tp2>
struct common_reference<_Tp1, _Tp2> : __common_reference_impl<_Tp1, _Tp2> {};

// If T1 and T2 are reference types and COMMON-REF(T1, T2) is well-formed, ...
template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1 &, _Tp2 &, 1, void_t<__common_ref<_Tp1 &, _Tp2 &>>> {
  using type = __common_ref<_Tp1 &, _Tp2 &>;
};

template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1 &&, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &&>>> {
  using type = __common_ref<_Tp1 &&, _Tp2 &&>;
};

template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1 &, _Tp2 &&, 1, void_t<__common_ref<_Tp1 &, _Tp2 &&>>> {
  using type = __common_ref<_Tp1 &, _Tp2 &&>;
};

template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1 &&, _Tp2 &, 1, void_t<__common_ref<_Tp1 &&, _Tp2 &>>> {
  using type = __common_ref<_Tp1 &&, _Tp2 &>;
};

// Otherwise, if basic_common_reference<...>::type is well-formed, ...
template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1, _Tp2, 2, void_t<__basic_common_ref<_Tp1, _Tp2>>> {
  using type = __basic_common_ref<_Tp1, _Tp2>;
};

// Otherwise, if COND-RES(T1, T2) is well-formed, ...
template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1, _Tp2, 3, void_t<__cond_res<_Tp1, _Tp2>>> {
  using type = __cond_res<_Tp1, _Tp2>;
};

// Otherwise, if common_type_t<T1, T2> is well-formed, ...
template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1, _Tp2, 4, void_t<common_type_t<_Tp1, _Tp2>>> {
  using type = common_type_t<_Tp1, _Tp2>;
};

// Otherwise, there shall be no member type.
template <typename _Tp1, typename _Tp2>
struct __common_reference_impl<_Tp1, _Tp2, 5, void> {};

// Otherwise, if sizeof...(T) is greater than two, ...
template <typename _Tp1, typename _Tp2, typename... _Rest>
struct common_reference<_Tp1, _Tp2, _Rest...>
    : __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>> {};

// Reuse __common_type_fold for common_reference<T1, T2, Rest...>
template <typename _Tp1, typename _Tp2, typename... _Rest>
struct __common_type_fold<common_reference<_Tp1, _Tp2>, __common_type_pack<_Rest...>,
                          void_t<common_reference_t<_Tp1, _Tp2>>>
    : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...> {};
/// @endcond

#  endif // C++2a

/// @} group metaprogramming

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std _GLIBCXX_VISIBILITY(default)

#endif // C++11

#endif // _GLIBCXX_TYPE_TRAITS
